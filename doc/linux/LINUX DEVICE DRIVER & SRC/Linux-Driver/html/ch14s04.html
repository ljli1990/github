<html xmlns:cf="http://docbook.sourceforge.net/xmlns/chunkfast/1.0">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>14.4.&#160;×ÜÏß, Éè±¸, ºÍÇı¶¯-LinuxÉè±¸Çı¶¯µÚÈı°æ£¨ÖĞÎÄ°æ£©</title>
<meta name="description" content="Çı¶¯¿ª·¢" />
<meta name="keywords" content="LinuxÉè±¸Çı¶¯,ÖĞÎÄ°æ,µÚÈı°æ,ldd,linux device driver,Çı¶¯¿ª·¢,µç×Ó°æ,³ÌĞòÉè¼Æ,Èí¼ş¿ª·¢,¿ª·¢ÆµµÀ" />
<meta name="verify-v1" content="5asbXwkS/Vv5OdJbK3Ix0X8osxBUX9hutPyUxoubhes=" />
<link rel="stylesheet" href="docbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.0">
<link rel="start" href="index.html" title="Linux Éè±¸Çı¶¯ Edition 3">
<link rel="up" href="ch14.html" title="µÚ&#160;14&#160;ÕÂ&#160;Linux Éè±¸Ä£ĞÍ">
<link rel="prev" href="ch14s03.html" title="14.3.&#160;ÈÈ²å°ÎÊÂ¼ş²úÉú">
<link rel="next" href="ch14s05.html" title="14.5.&#160;Àà">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">14.4.&#160;×ÜÏß, Éè±¸, ºÍÇı¶¯</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="ch14s03.html">ÉÏÒ»Ò³</a>&#160;</td>
<th width="60%" align="center">µÚ&#160;14&#160;ÕÂ&#160;Linux Éè±¸Ä£ĞÍ</th>
<td width="20%" align="right">&#160;<a accesskey="n" href="ch14s05.html">ÏÂÒ»Ò³</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="BuesDevicesandDrivers.sect"></a>14.4.&#160;×ÜÏß, Éè±¸, ºÍÇı¶¯</h2></div></div></div>
<p>ÖÁ½ñ, ÎÒÃÇÒÑ¾­¿´µ½´óÁ¿µÍ¼¶¿ò¼ÜºÍÒ»¸öÏà¶ÔÉÙµÄÀı×Ó. ÎÒÃÇÊÔÍ¼ÔÚ±¾ÕÂÊ£ÏÂ²¿·ÖÖĞ²¹³ä, Ëæ×ÅÎÒÃÇ½øÈë Linux Éè±¸Ä£ĞÍµÄ¸ü¸ß¼¶. Îª´Ë, ÎÒÃÇ½éÉÜÒ»¸öĞÂµÄĞéÄâ×ÜÏß, ÎÒÃÇ³ÆÎª lddbus, <sup>[<a name="id485223" href="#ftn.id485223">46</a>]</sup>²¢ÇÒĞŞ¸Ä scullp Çı¶¯À´ "½ÓÈë" µ½Õâ¸ö×ÜÏß.</p>
<p>ÔÙÒ»´Î, Ğí¶àÇı¶¯×÷Õß½«²»»áĞèÒªÕâÀïÉæ¼°µÄ²ÄÁÏ. Õâ¸öË®Æ½µÄÏ¸½ÚÍ¨³£ÔÚ×ÜÏß¼¶±ğ´¦Àí, ²¢ÇÒºÜÉÙ×÷ÕßĞèÒªÌí¼ÓÒ»¸öĞÂ×ÜÏßÀàĞÍ. Õâ¸öĞÅÏ¢ÊÇÓĞÓÃµÄ, µ«ÊÇ, ¶ÔÈÎºÎÈËºÃÆæÔÚ PCI, USB µÈ²ãÃæµÄÀïÃæ·¢ÉúÁËÊ²Ã´»òÕßË­ĞèÒªÔÚÄÇ¸ö¼¶±ğ×ö¸Ä±ä. </p>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="Buses.sect"></a>14.4.1.&#160;×ÜÏß</h3></div></div></div>
<p>Ò»¸ö×ÜÏßÊÇ´¦ÀíÆ÷ºÍÒ»¸ö»ò¶à¸öÉè±¸Ö®¼äµÄÍ¨µÀ. ÎªÉè±¸Ä£ĞÍµÄÄ¿µÄ, ËùÓĞµÄÉè±¸¶¼Í¨¹ıÒ»¸ö×ÜÏßÁ¬½Ó, ÉõÖÁµ±ËüÊÇÒ»¸öÄÚ²¿µÄĞéÄâµÄ,"Æ½Ì¨"×ÜÏß. ×ÜÏß¿ÉÒÔ²åÈëÁíÒ»¸ö - Ò»¸ö USB ¿ØÖÆÆ÷³£³£ÊÇÒ»¸ö PCI Éè±¸, ÀıÈç. Éè±¸Ä£ĞÍ±íÊ¾ÔÚ×ÜÏßºÍËüÃÇ¿ØÖÆµÄÉè±¸Ö®¼äµÄÊµ¼ÊÁ¬½Ó.</p>
<p></p>
<p>ÔÚ Linux Éè±¸Ä£ĞÍÖĞ, Ò»¸ö×ÜÏßÓÉ bus_type ½á¹¹´ú±í, ¶¨ÒåÔÚ &lt;linux/device.h&gt;. Õâ¸ö½á¹¹¿´À´Ïó:</p>
<pre class="programlisting">
struct bus_type {
 char *name;
 struct subsystem subsys;
 struct kset drivers;
 struct kset devices;
 int (*match)(struct device *dev, struct device_driver *drv);
 struct device *(*add)(struct device * parent, char * bus_id);
 int (*hotplug) (struct device *dev, char **envp,
 int num_envp, char *buffer, int buffer_size);
 /* Some fields omitted */
};
</pre>
<p>name ³ÉÔ±ÊÇ×ÜÏßµÄÃû×Ó, ÓĞĞ©Í¬ pci. Äã¿É´ÓÕâ¸ö½á¹¹ÖĞ¼ûµ½Ã¿¸ö×ÜÏßÊÇËü×Ô¼ºµÄ×ÓÏµÍ³; Õâ¸ö×ÓÏµÍ³²»Î»ÓÚ sysfs µÄ¶¥²ã, µ«ÊÇ. Ïà·´, ËüÃÇÔÚ×ÜÏß×ÓÏµÍ³ÏÂÃæ. Ò»¸ö×ÜÏß°üº¬ 2 ¸ö ksets, ´ú±íÒÑÖªµÄ×ÜÏßµÄÇı¶¯ºÍËùÓĞ²åÈë×ÜÏßµÄÉè±¸. ËùÒÔ, ÓĞÒ»Ì×·½·¨ÎÒÃÇÂíÉÏ½«Éæ¼°.</p>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="Busregisteration.sect"></a>14.4.1.1.&#160;×ÜÏß×¢²á</h4></div></div></div>
<p>ÈçÍ¬ÎÒÃÇÌá¹ıµÄ, Àı×ÓÔ´Âë°üº¬Ò»¸öĞéÄâ×ÜÏßÊµÏÖ³ÆÎª lddbus. Õâ¸ö×ÜÏß½¨Á¢ËüµÄ bus_type ½á¹¹, ÈçÏÂ:</p>
<pre class="programlisting">
struct bus_type ldd_bus_type = { .name = "ldd", .match = ldd_match, .hotplug = ldd_hotplug, };
</pre>
<p>×¢ÒâºÜÉÙ bus_type ³ÉÔ±ÒªÇó³õÊ¼»¯; ´ó²¿·ÖÓÉÉè±¸Ä£ĞÍºËĞÄ´¦Àí. µ«ÊÇ, ÎÒÃÇÈ·Êµ²»µÃ²»Ö¸¶¨×ÜÏßµÄÃû×Ó, ÒÔ¼°ÈÎºÎ°éËæËüµÄ·½·¨.</p>
<p>²»¿É±ÜÃâµØ, Ò»¸öĞÂ×ÜÏß±ØĞë×¢²áµ½ÏµÍ³, Í¨¹ıÒ»¸ö¶Ô bus_register µÄµ÷ÓÃ. lddbus ´úÂëÕâÑù×öÒÔÕâÑùµÄ·½Ê½:</p>
<pre class="programlisting">
ret = bus_register(&amp;ldd_bus_type);
if (ret)
 return ret; 
</pre>
<p>Õâ¸öµ÷ÓÃ¿ÉÄÜÊ§°Ü, µ±È», Òò´Ë·µ»ØÖµ±ØĞëÒ»Ö±¼ì²é. Èç¹ûËü³É¹¦, ĞÂ×ÜÏß×ÓÏµÍ³ÒÑ±»Ìí¼Óµ½ÏµÍ³; ÔÚ sysfs ÖĞ /sys/bus µÄÏÂÃæ¿ÉÒÔ¼ûµ½, ²¢ÇÒ¿ÉÄÜÆô¶¯Ìí¼ÓÉè±¸.</p>
<p>Èç¹ûÓĞ±ØÒª´ÓÏµÍ³ÖĞÈ¥³ıÒ»¸ö×ÜÏß(µ±¹ØÁªÄ£¿é±»È¥³ı, ÀıÈç), µ÷ÓÃµ÷ÓÃ bus_unregister:</p>
<pre class="programlisting">
void bus_unregister(struct bus_type *bus); 
</pre>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="Busmethods.sect"></a>14.4.1.2.&#160;×ÜÏß·½·¨</h4></div></div></div>
<p>ÓĞ¼¸¸ö¸ø bus_type ½á¹¹¶¨ÒåµÄ·½·¨; ËüÃÇÔÊĞí×ÜÏß´úÂë×÷ÎªÒ»¸öÉè±¸ºËĞÄºÍµ¥¶ÀÇı¶¯Ö®¼äµÄÖĞ½é. ÔÚ 2.6.10 ÄÚºËÖĞ¶¨ÒåµÄ·½·¨ÊÇ:</p>
<div class="variablelist"><dl>
<dt><span class="term"><span>int (*match)(struct device *device, struct device_driver *driver);</span></span></dt>
<dd><p>Õâ¸ö·½·¨±»µ÷ÓÃ, ´ó¸Å¶à´Î, ÎŞÂÛºÎÊ±Ò»¸öĞÂÉè±¸»òÕßÇı¶¯±»Ìí¼Ó¸øÕâ¸ö×ÜÏß. ËüÓ¦µ±·µ»ØÒ»¸ö·ÇÁãÖµÈç¹û¸ø¶¨µÄÉè±¸¿É±»¸ø¶¨µÄÇı¶¯´¦Àí. (ÎÒÃÇÂíÉÏ½øÈëÉè±¸ºÍ device_driver ½á¹¹µÄÏ¸½Ú). Õâ¸öº¯Êı±ØĞëÔÚ×ÜÏß¼¶±ğ´¦Àí, ÒòÎªÄÇÊÇºÏÊÊµÄÂß¼­´æÔÚµÄµØ·½; ºËĞÄÄÚºË²»ÄÜÖªµÀÈçºÎÆ¥ÅäÃ¿¸ö¿ÉÄÜ×ÜÏßÀàĞÍµÄÉè±¸ºÍÇı¶¯.</p></dd>
<dt><span class="term"><span>int (*hotplug) (struct device *device, char **envp, int num_envp, char *buffer, int buffer_size);</span></span></dt>
<dd><p>Õâ¸öÄ£¿éÔÊĞí×ÜÏßÌí¼Ó±äÁ¿µ½»·¾³ÖĞ, ÔÚ²úÉúÒ»¸öÈÈ²å°ÎÊÂ¼şÔÚÓÃ»§¿Õ¼äÖ®Ç°. ²ÎÊıºÍ kset ÈÈ²å°Î·½·¨ÏàÍ¬( ÔÚÇ°ÃæµÄ "ÈÈ²å°ÎÊÂ¼ş²úÉú" Ò»½ÚÖĞÃèÊö ).</p></dd>
</dl></div>
<p>lddbus Çı¶¯ÓĞÒ»¸ö·Ç³£¼òµ¥µÄÆ¥Åäº¯Êı, Ëü½ö½ö±È½ÏÇı¶¯ºÍÉè±¸µÄÃû×Ó:</p>
<pre class="programlisting">
static int ldd_match(struct device *dev, struct device_driver *driver)
{
 return !strncmp(dev-&gt;bus_id, driver-&gt;name, strlen(driver-&gt;name));
}
</pre>
<p>µ±Éæ¼°µ½ÕæÊµÓ²¼ş, match º¯Êı³£³£ÔÚÓĞÉè±¸×ÔÉíÌá¹©µÄÓ²¼ş ID ºÍÇı¶¯Ìá¹©µÄ ID Ö®¼ä, ×öÒ»Ğ©±È½Ï.</p>
<p>lddbus ÈÈ²å°Î·½·¨¿´À´ÏóÕâÑù:</p>
<pre class="programlisting">
static int ldd_hotplug(struct device *dev, char **envp, int num_envp, char *buffer, int buffer_size)
{
 envp[0] = buffer;
 if (snprintf(buffer, buffer_size, "LDDBUS_VERSION=%s",
 Version) &gt;= buffer_size)
 return -ENOMEM;
 envp[1] = NULL;
 return 0;
}
</pre>
<p>ÕâÀï, ÎÒÃÇ¼ÓÈë lddbus Ô´ÂëµÄµ±Ç°°æ±¾ºÅ, Ö»ÊÇÒÔ·ÀÓĞÈËºÃÆæ.</p>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="Iteratingoverdevicesanddrivers.sect"></a>14.4.1.3.&#160;ÁĞ¾ÙÉè±¸ºÍÇı¶¯</h4></div></div></div>
<p>Èç¹ûÄãÔÚ±àĞ´×ÜÏß¼¶±ğµÄ´úÂë, Äã¿ÉÄÜ²»µÃ²»¶ÔËùÓĞÒÑ¾­×¢²áµ½ÄãµÄ×ÜÏßµÄÉè±¸»òÇı¶¯½øĞĞÒ»Ğ©²Ù×÷. Ëü¿ÉÄÜ»áÓÕ»óÈËÖ±½Ó½øÈë bus_type ½á¹¹ÖĞµÄ¸÷ÖÖ½á¹¹, µ«ÊÇ×îºÃÊ¹ÓÃÒÑ¾­Ìá¹©µÄ°ïÖúº¯Êı.</p>
<p>Îª²Ù×÷Ã¿¸ö¶Ô×ÜÏßÒÑÖªµÄÉè±¸, Ê¹ÓÃ:</p>
<pre class="programlisting">
int bus_for_each_dev(struct bus_type *bus, struct device *start, void *data, int (*fn)(struct device *, void *));
</pre>
<p>Õâ¸öº¯ÊıÁĞ¾Ù×ÜÏßÉÏµÄÃ¿¸öÉè±¸, ´«µİ¹ØÁªµÄÉè±¸½á¹¹¸ø fn, Á¬Í¬×÷Îª data À´´«µİµÄÖµ. Èç¹û start ÊÇ NULL, ÁĞ¾Ù´Ó×ÜÏßµÄµÚÒ»¸öÉè±¸¿ªÊ¼; ·ñÔòÁĞ¾Ù´Ó start Ö®ºóµÄµÚÒ»¸öÉè±¸¿ªÊ¼. Èç¹û fn ·µ»ØÒ»¸ö·ÇÁãÖµ, ÁĞ¾ÙÍ£Ö¹²¢ÇÒÄÇ¸öÖµ´Ó bus_for_each_dev ·µ»Ø.</p>
<p>ÓĞÒ»¸öÀàËÆµÄº¯ÊıÀ´ÁĞ¾ÙÇı¶¯:</p>
<pre class="programlisting">
int bus_for_each_drv(struct bus_type *bus, struct device_driver *start, void *data, int (*fn)(struct device_driver *, void *));
</pre>
<p>Õâ¸öº¯Êı¾ÍÏñ buf_for_each_dev, ³ıÁË, µ±È», ËüÌæÖ®×÷ÓÃÓÚÇı¶¯.</p>
<p>Ó¦µ±×¢Òâ, Õâ 2 ¸öº¯Êı³ÖÓĞ×ÜÏß×ÓÏµÍ³µÄ¶ÁÕß/Ğ´ÕßÆì±êÔÚ¹¤×÷ÆÚ¼ä. Òò´ËÊÔÍ¼Ò»ÆğÊ¹ÓÃÕâ 2 ¸ö»áËÀËø -- Ã¿¸ö½«ÊÔÍ¼»ñÈ¡Í¬Ò»¸öÆì±ê. ĞŞ¸Ä×ÜÏßµÄ²Ù×÷( ÀıÈç×¢ÏúÉè±¸ )Ò²½«Ëø×¡. Òò´Ë, Ğ¡ĞÄÊ¹ÓÃ bus_for_each º¯Êı.</p>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="Busattributes.sect"></a>14.4.1.4.&#160;×ÜÏßÊôĞÔ</h4></div></div></div>
<p>¼¸ºõ Linux Çı¶¯Ä£ĞÍÖĞµÄÃ¿Ò»²ã¶¼Ìá¹©Ò»¸öÌí¼ÓÊôĞÔµÄ½Ó¿Ú, ²¢ÇÒ×ÜÏß²ã²»ÀıÍâ. bus_attribute ÀàĞÍ¶¨ÒåÔÚ &lt;linux/device.h&gt; ÈçÏÂ:</p>
<pre class="programlisting">
struct bus_attribute {
 struct attribute attr;
 ssize_t (*show)(struct bus_type *bus, char *buf);
 ssize_t (*store)(struct bus_type *bus, const char *buf,
 size_t count);
};
</pre>
<p>ÎÒÃÇÒÑ¾­¼ûµ½ struct attribute ÔÚ "È±Ê¡ÊôĞÔ" Ò»½Ú. bus_attribute ÀàĞÍÒ²°üº¬ 2 ¸ö·½·¨À´ÏÔÊ¾ºÍÉèÖÃÊôĞÔÖµ. ´ó²¿·ÖÔÚ kobject Ö®ÉÏµÄÉè±¸Ä£ĞÍ²ãÒÔÕâÖÖ·½Ê½¹¤×÷.</p>
<p>ÒÑ¾­Ìá¹©ÁËÒ»¸ö·½±ãµÄºêÎªÔÚ±àÒëÊ±¼ä´´½¨ºÍ³õÊ¼»¯ bus_attribute ½á¹¹:</p>
<pre class="programlisting">
BUS_ATTR(name, mode, show, store);
</pre>
<p>Õâ¸öºêÉùÃ÷Ò»¸ö½á¹¹, ²úÉúËüµÄÃû×ÓÍ¨¹ıÇ°×º×Ö·û´® bus_attr_ µ½¸ø¶¨µÄÃû×Ó.</p>
<p>ÈÎºÎÊôÓÚÒ»¸ö×ÜÏßµÄÊôĞÔÓ¦µ±Ã÷È·Ê¹ÓÃ bus_create_file À´´´½¨:</p>
<pre class="programlisting">
int bus_create_file(struct bus_type *bus, struct bus_attribute *attr); 
</pre>
<p>ÊôĞÔÒ²¿É±»È¥³ı, Ê¹ÓÃ:</p>
<pre class="programlisting">
void bus_remove_file(struct bus_type *bus, struct bus_attribute *attr); 
</pre>
<p>lddbus Çı¶¯´´½¨Ò»¸ö¼òµ¥ÊôĞÔÎÄ¼ş, ÔÙ´Î, °üº¬Ô´Âë°æ±¾ºÅ. show ·½·¨ºÍ bus_attribute ½á¹¹ÉèÖÃÈçÏÂ:</p>
<pre class="programlisting">
static ssize_t show_bus_version(struct bus_type *bus, char *buf)
{
 return snprintf(buf, PAGE_SIZE, "%s\n", Version);
}

static BUS_ATTR(version, S_IRUGO, show_bus_version, NULL); 
</pre>
<p>´´½¨ÊôĞÔÎÄ¼şÔÚÄ£¿é¼ÓÔØÊ±¼äÍê³É:</p>
<pre class="programlisting">
if (bus_create_file(&amp;ldd_bus_type, &amp;bus_attr_version))
 printk(KERN_NOTICE "Unable to create version attribute\n");
</pre>
<p>Õâ¸öµ÷ÓÃ´´½¨Ò»¸öÊôĞÔÎÄ¼ş(/sys/busldd/version) °üº¬ lddbus ´úÂëµÄ°æ±¾ºÅ.</p>
</div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="Devices.sect"></a>14.4.2.&#160;Éè±¸</h3></div></div></div>
<p>ÔÚ×îµÍ²ã, Linux ÏµÍ³ÖĞµÄÃ¿¸öÉè±¸ÓÉÒ»¸ö struct device ´ú±í:</p>
struct device {
 struct device *parent;
 struct kobject kobj;
 char bus_id[BUS_ID_SIZE];
 struct bus_type *bus;
 struct device_driver *driver;
 void *driver_data;
 void (*release)(struct device *dev);
 /* Several fields omitted */

}; 
<p>ÓĞĞí¶àÆäËûµÄ struct device ³ÉÔ±Ö»¶ÔÉè±¸ºËĞÄ´úÂë¸ĞĞËÈ¤. µ«ÊÇ, ÕâĞ©³ÉÔ±ÖµµÃÁË½â:</p>
<div class="variablelist"><dl>
<dt><span class="term"><span>struct device *parent </span></span></dt>
<dd><p>Éè±¸µÄ "parent" Éè±¸ -- ËüËù¸½×Åµ½µÄÉè±¸. ÔÚ´ó²¿·ÖÇé¿ö, Ò»¸ö¸¸Éè±¸ÊÇÄ³ÖÖ×ÜÏß»òÕßÖ÷¿ØÖÆÆ÷. Èç¹û parent ÊÇ NULL, Éè±¸ÊÇÒ»¸ö¶¥²ãÉè±¸, Õâ³£³£²»ÊÇÄãËùÒªµÄ.</p></dd>
<dt><span class="term"><span>struct kobject kobj;</span></span></dt>
<dd><p>´ú±íÕâ¸öÉè±¸²¢ÇÒÁ¬½ÓËüµ½²ã´ÎÖĞµÄ kobject. ×¢Òâ, ×÷ÎªÒ»¸öÍ¨ÓÃµÄ¹æÔò, device-&gt;kobj-&gt;parent µÈÍ¬ÓÚ device-&gt;parent-&gt;kobj.</p></dd>
<dt><span class="term"><span>char bus_id[BUS_ID_SIZE];</span></span></dt>
<dd><p>Î¨Ò»È·¶¨Õâ¸ö×ÜÏßÉÏµÄÉè±¸µÄ×Ö·û´®. PCI Éè±¸, ÀıÈç, Ê¹ÓÃ±ê×¼µÄ PCI ID ¸ñÊ½, °üº¬Óò, ×ÜÏß, Éè±¸, ºÍ¹¦ÄÜºÅ.</p></dd>
<dt><span class="term"><span>struct bus_type *bus;</span></span></dt>
<dd><p>È·¶¨Éè±¸Î»ÓÚÄÄÖÖ×ÜÏß.</p></dd>
<dt><span class="term"><span>struct device_driver *driver;</span></span></dt>
<dd><p>¹ÜÀíÕâ¸öÉè±¸µÄÇı¶¯; ÎÒÃÇ²é¿´ struct device_driver ÔÚÏÂÒ»½Ú.</p></dd>
<dt><span class="term"><span>void *driver_data;</span></span></dt>
<dd><p>Ò»¸ö¿ÉÄÜ±»Éè±¸Çı¶¯Ê¹ÓÃµÄË½ÓĞÊı¾İ³ÉÔ±.</p></dd>
<dt><span class="term"><span>void (*release)(struct device *dev);</span></span></dt>
<dd><p>µ±¶ÔÕâ¸öÉè±¸µÄ×îºóÒıÓÃ±»È¥³ıÊ±µ÷ÓÃµÄ·½·¨; Ëü´Ó±»Ç¶ÈëµÄ kobject µÄ release ·½·¨±»µ÷ÓÃ. ×¢²áµ½ºËĞÄµÄËùÓĞµÄÉè±¸½á¹¹±ØĞëÓĞÒ»¸ö release ·½·¨, ·ñÔòÄÚºË´òÓ¡³ö»ÅÂÒµÄ±§Ô¹.</p></dd>
</dl></div>
<p>×îÉÙ, parent, bus_id, bus, ºÍ release ³ÉÔ±±ØĞëÔÚÉè±¸½á¹¹±»×¢²áÇ°ÉèÖÃ.</p>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="Deviceregisteration.sect"></a>14.4.2.1.&#160;Éè±¸×¢²á</h4></div></div></div>
<p>Í¨³£µÄ×¢²áºÍ×¢Ïúº¯ÊıÔÚ:</p>
<pre class="programlisting">
int device_register(struct device *dev);
void device_unregister(struct device *dev);
</pre>
<p>ÎÒÃÇÒÑ¾­¼ûµ½ lddbus ´úÂëÈçºÎ×¢²áËüµÄ×ÜÏßÀàĞÍ. µ«ÊÇ, Ò»¸öÊµ¼ÊµÄ×ÜÏßÊÇÒ»¸öÉè±¸²¢ÇÒ±ØĞëµ¥¶À×¢²á. Îª¼òµ¥Æğ¼û, lddbus Ä£¿éÖ»Ö§³ÖÒ»¸öµ¥¸öĞéÄâ×ÜÏß, Òò´ËÕâ¸öÇı¶¯ÔÚ±àÒëÊ±½¨Á¢ËüµÄÉè±¸:</p>
<pre class="programlisting">
static void ldd_bus_release(struct device *dev)
{
 printk(KERN_DEBUG "lddbus release\n");
}

struct device ldd_bus = {
 .bus_id = "ldd0",
 .release = ldd_bus_release

}; 
</pre>
<p>ÕâÊÇ¶¥¼¶×ÜÏß, Òò´Ë parent ºÍ bus ³ÉÔ±ÁôÎª NULL. ÎÒÃÇÓĞÒ»¸ö¼òµ¥µÄ, no-op release ·½·¨, ²¢ÇÒ, ×÷ÎªµÚÒ»¸ö(²¢ÇÒÎ¨Ò»)×ÜÏß, ËüµÄÃû×ÓÊ± ldd0. Õâ¸ö×ÜÏßÉè±¸±»×¢²á, Ê¹ÓÃ:</p>
<pre class="programlisting">
ret = device_register(&amp;ldd_bus);
if (ret)
 printk(KERN_NOTICE "Unable to register ldd0\n");
</pre>
<p>Ò»µ©µ÷ÓÃÍê³É, ĞÂ×ÜÏß¿ÉÔÚ sysfs ÖĞ /sys/devices ÏÂÃæ¼ûµ½. ÈÎºÎ¼Óµ½Õâ¸ö×ÜÏßµÄÉè±¸½Ó×ÅÔÚ /sys/devices/ldd0 ÏÂÏÔÊ¾.</p>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="Deviceattributes.sect3"></a>14.4.2.2.&#160;Éè±¸ÊôĞÔ</h4></div></div></div>
<p>sysfs ÖĞµÄÉè±¸Èë¿Ú¿ÉÓĞÊôĞÔ. Ïà¹ØµÄ½á¹¹ÊÇ:</p>
<pre class="programlisting">
struct device_attribute {
 struct attribute attr;
 ssize_t (*show)(struct device *dev, char *buf);
 ssize_t (*store)(struct device *dev, const char *buf,
 size_t count);
};
</pre>
<p>ÕâĞ©ÊôĞÔ½á¹¹¿ÉÔÚ±àÒëÊ±½¨Á¢, Ê¹ÓÃÕâĞ©ºê:</p>
<pre class="programlisting">
DEVICE_ATTR(name, mode, show, store);
</pre>
<p>½á¹û½á¹¹Í¨¹ıÇ°×º dev_attr_ µ½¸ø¶¨Ãû×ÓÉÏÀ´ÃüÃû. ÊôĞÔÎÄ¼şµÄÊµ¼Ê¹ÜÀíÊ¹ÓÃÍ¨³£µÄº¯Êı¶ÔÀ´´¦Àí:</p>
<pre class="programlisting">
int device_create_file(struct device *device, struct device_attribute *entry);
void device_remove_file(struct device *dev, struct device_attribute *attr);
</pre>
<p>struct bus_type µÄ dev_attrs ³ÉÔ±Ö¸ÏòÒ»¸öÈ±Ê¡µÄÊôĞÔÁĞ±í, ÕâĞ©ÊôĞÔ¸øÌí¼Óµ½×ÜÏßµÄÃ¿¸öÉè±¸´´½¨.</p>
</div>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="Devicestructureembedding.sect3"></a>14.4.2.3.&#160;Éè±¸½á¹¹Ç¶Èë</h4></div></div></div>
<p>Éè±¸½á¹¹°üº¬Éè±¸Ä£ĞÍºËĞÄĞèÒªµÄÀ´Ä£ĞÍ»¯ÏµÍ³µÄĞÅÏ¢. ´ó²¿·Ö×ÓÏµÍ³, µ«ÊÇ, ¸ú×Ù¹ØÓÚËüÃÇ×¤ÁôµÄÉè±¸µÄ¶îÍâĞÅÏ¢. ½á¹û, ¶ÔÉè±¸ºÜÉÙÓÉ¿ÕÉè±¸½á¹¹Ëù´ú±í; Ïà·´, Õâ¸ö½á¹¹, ÈçÍ¬ kobject ½á¹¹, ³£³£ÊÇÇ¶ÈëÒ»¸ö¸ü¸ß¼¶µÄÉè±¸±íÊ¾ÖĞ. Èç¹ûÄã²é¿´ struct pci_dev µÄ¶¨Òå»òÕß struct usb_device µÄ¶¨Òå, Äã»á·¢ÏÖÒ»¸ö struct device ÂñÔÚÆäÖĞ. ³£³£µØ, µÍ²ãÇı¶¯ÉõÖÁ²»ÖªµÀ struct device, µ«ÊÇÓĞÀıÍâ.</p>
<p>lddbus Çı¶¯´´½¨Ëü×Ô¼ºµÄÉè±¸ÀàĞÍ( struct ldd_device ) ²¢ÇÒÆÚÍûµ¥¶ÀµÄÉè±¸Çı¶¯À´×¢²áËüÃÇµÄÉè±¸Ê¹ÓÃÕâ¸öÀàĞÍ. ËüÊÇÒ»¸ö¼òµ¥½á¹¹:</p>
<pre class="programlisting">
struct ldd_device {
 char *name;
 struct ldd_driver *driver;
 struct device dev; 
}; 
#define to_ldd_device(dev) container_of(dev, struct ldd_device, dev); 
</pre>
<p>Õâ¸ö½á¹¹ÔÊĞíÇı¶¯Ìá¹©Ò»¸öÊµ¼ÊµÄÃû×Ó¸øÉè±¸( Õâ¿ÉÒÔÇå³şµØ²»Í¬ÓÚËüµÄ×ÜÏß ID, ´æ´¢ÓÚÉè±¸½á¹¹) ÒÔ¼°Ò»¸öÕâĞ©Çı¶¯ĞÅÏ¢µÄÖ¸Õë. ¸øÕæÊµÉè±¸µÄ½á¹¹³£³£»¹°üº¬¹ØÓÚ¹©Ó¦ÕßĞÅÏ¢, Éè±¸ĞÍºÅ, Éè±¸ÅäÖÃ, Ê¹ÓÃµÄ×ÊÔ´, µÈµÈ. ¿ÉÒÔÔÚ struct pci_dev (&lt;linux/pci.h&gt;) »òÕß struct usb_device (&lt;linux/usb.h&gt;) ÖĞÕÒµ½ºÃµÄÀı×Ó. Ò»¸ö·½±ãµÄºê( to_ldd_device ) Ò²Îª struct ldd_device ¶¨Òå, Ê¹µÃÈİÒ××ª»»Ö¸Ïò±»Ç¶ÈëµÄ½á¹¹µÄÖ¸ÕëÎª ldd_device Ö¸Õë.</p>
<p>lddbus Êä³öµÄ×¢²á½Ó¿Ú¿´À´Èç´Ë:</p>
<pre class="programlisting">
int register_ldd_device(struct ldd_device *ldddev) 
{
 ldddev-&gt;dev.bus = &amp;ldd_bus_type;
 ldddev-&gt;dev.parent = &amp;ldd_bus;
 ldddev-&gt;dev.release = ldd_dev_release;
 strncpy(ldddev-&gt;dev.bus_id, ldddev-&gt;name, BUS_ID_SIZE);
 return device_register(&amp;ldddev-&gt;dev);

}
EXPORT_SYMBOL(register_ldd_device);
</pre>
<p>ÕâÀï, ÎÒÃÇ¼òµ¥µØÌî³äÒ»Ğ©Ç¶ÈëµÄÉè±¸½á¹¹³ÉÔ±( µ¥¸öÇı¶¯²»Ó¦µ±ĞèÒªÖªµÀÕâ¸ö ), ²¢ÇÒ×¢²áÕâ¸öÉè±¸µ½Çı¶¯ºËĞÄ. Èç¹ûÎÒÃÇÏëÌí¼Ó×ÜÏßÌØ¶¨µÄÊôĞÔµ½Éè±¸, ÎÒÃÇ¿ÉÔÚÕâÀï×ö.</p>
<p>ÎªÏÔÊ¾Õâ¸ö½Ó¿ÚÈçºÎÊ¹ÓÃ, ÎÒÃÇ½éÉÜÁíÒ»¸öÀı×ÓÇı¶¯, ÎÒÃÇ³ÆÎª sculld. ËüÊÇÔÚµÚ 8 ÕÂ½éÉÜµÄ scullp Çı¶¯ÉÏµÄÁíÒ»¸ö±äÌå. ËüÊµÏÖÍ¨ÓÃµÄÄÚ´æÇøÉè±¸, µ«ÊÇ sculld Ò²Ê¹ÓÃ Linux Éè±¸Ä£ĞÍ, Í¨¹ı lddbus ½Ó¿Ú.</p>
<p>sculld Çı¶¯Ìí¼ÓÒ»¸öËü×Ô¼ºµÄÊôĞÔµ½ËüµÄÉè±¸Èë¿Ú; Õâ¸öÊôĞÔ, ³ÆÎª dev, ½ö½ö°üº¬¹ØÁªµÄÉè±¸ºÅ. Õâ¸öÊôĞÔ¿É±»Ò»¸öÄ£¿éÓÃÀ´¼ÓÔØ½Å±¾»òÕßÈÈ²å°Î×ÓÏµÍ³, À´×Ô¶¯´´½¨Éè±¸½Úµã, µ±Éè±¸±»Ìí¼Óµ½ÏµÍ³Ê±. Õâ¸öÊôĞÔµÄÉèÖÃ×ñÑ­³£ÓÃÄ£Ê½:</p>
<pre class="programlisting">
static ssize_t sculld_show_dev(struct device *ddev, char *buf)
{
 struct sculld_dev *dev = ddev-&gt;driver_data;

 return print_dev_t(buf, dev-&gt;cdev.dev);
}

static DEVICE_ATTR(dev, S_IRUGO, sculld_show_dev, NULL);
</pre>
<p>½Ó×Å, ÔÚ³õÊ¼»¯Ê±¼ä, Éè±¸±»×¢²á, ²¢ÇÒ dev ÊôĞÔ±»´´½¨Í¨¹ıÏÂÃæµÄº¯Êı:</p>
<pre class="programlisting">
static void sculld_register_dev(struct sculld_dev *dev, int index) 
{
 sprintf(dev-&gt;devname, "sculld%d", index);
 dev-&gt;ldev.name = dev-&gt;devname;
 dev-&gt;ldev.driver = &amp;sculld_driver;
 dev-&gt;ldev.dev.driver_data = dev;
 register_ldd_device(&amp;dev-&gt;ldev);
 device_create_file(&amp;dev-&gt;ldev.dev, &amp;dev_attr_dev);

} 
</pre>
<p>×¢Òâ, ÎÒÃÇÊ¹ÓÃ driver_data ³ÉÔ±À´´æ´¢Ö¸ÏòÎÒÃÇ×Ô¼ºµÄÄÚ²¿µÄÉè±¸½á¹¹µÄÖ¸Õë.</p>
</div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="DeviceDrivers.sect2"></a>14.4.3.&#160;Éè±¸Çı¶¯</h3></div></div></div>
<p>Éè±¸Ä£ĞÍ¸ú×ÙËùÓĞ¶ÔÏµÍ³ÒÑÖªµÄÇı¶¯. Õâ¸ö¸ú×ÙµÄÖ÷ÒªÔ­ÒòÊÇÊ¹Çı¶¯ºËĞÄÄÜÆ¥ÅäÇı¶¯ºÍĞÂÉè±¸. Ò»µ©Çı¶¯ÔÚÏµÍ³ÖĞÊÇÒÑÖªµÄ¶ÔÏó, µ«ÊÇ, Ğí¶àÆäËûµÄÊÂÇé±äµÃÓĞ¿ÉÄÜ. Éè±¸Çı¶¯¿ÉÊä³öºÍÈÎºÎÌØ¶¨Éè±¸ÎŞ¹ØµÄĞÅÏ¢ºÍÅäÖÃ±äÁ¿, ÀıÈç:</p>
<p>Çı¶¯ÓÉÏÂÁĞ½á¹¹¶¨Òå:</p>
<pre class="programlisting">
struct device_driver {
 char *name;
 struct bus_type *bus;
 struct kobject kobj;
 struct list_head devices;
 int (*probe)(struct device *dev);
 int (*remove)(struct device *dev);
 void (*shutdown) (struct device *dev);
}; 
</pre>
<p>ÔÙÒ»´Î, ¼¸¸ö½á¹¹³ÉÔ±±»ºöÂÔ( È«²¿ÄÚÈİ¼û &lt;linux/device.h&gt; ). ÕâÀï, name ÊÇÇı¶¯µÄÃû×Ó( ËüÔÚ sysfs ÖĞ³öÏÖ ), bus ÊÇÕâ¸öÇı¶¯Ê¹ÓÃµÄ×ÜÏßÀàĞÍ, kobj ÊÇ±ØÈ»µÄ kobject, devices ÊÇµ±Ç°°ó¶¨µ½Õâ¸öÇı¶¯µÄËùÓĞÉè±¸µÄÁĞ±í, probe ÊÇÒ»¸öº¯Êı±»µ÷ÓÃÀ´²éÑ¯Ò»¸öÌØ¶¨Éè±¸µÄ´æÔÚ(ÒÔ¼°Õâ¸öÇı¶¯ÊÇ·ñ¿ÉÒÔÊ¹ÓÃËü), remove µ±Éè±¸´ÓÏµÍ³ÖĞÈ¥³ıÊ±±»µ÷ÓÃ, shutdown ÔÚ¹Ø±ÕÊ±±»µ÷ÓÃÀ´¹Ø±ÕÉè±¸.</p>
<p>Ê¹ÓÃ device_driver ½á¹¹µÄº¯ÊıµÄĞÎÊ½, ÏÖÔÚÓ¦µ±¿´À´ÊÇÀàËÆµÄ(Òò´ËÎÒÃÇ¿ìËÙº­¸ÇËüÃÇ). ×¢²áº¯ÊıÊÇ:</p>
<pre class="programlisting">
int driver_register(struct device_driver *drv);
void driver_unregister(struct device_driver *drv);
</pre>
<p>Í¨³£µÄÊôĞÔ½á¹¹ÔÚ:</p>
<pre class="programlisting">
struct driver_attribute {
 struct attribute attr;
 ssize_t (*show)(struct device_driver *drv, char *buf);
 ssize_t (*store)(struct device_driver *drv, const char *buf,

 size_t count);
};
DRIVER_ATTR(name, mode, show, store);
</pre>
<p>ÒÔ¼°ÊôĞÔÎÄ¼şÒÔÍ¨³£µÄ·½·¨´´½¨:</p>
<pre class="programlisting">
int driver_create_file(struct device_driver *drv, struct driver_attribute *attr);
void driver_remove_file(struct device_driver *drv, struct driver_attribute *attr);
</pre>
<p>bus_type ½á¹¹º¬ÓĞÒ»¸ö³ÉÔ±( drv_attrs ) Ö¸ÏòÒ»Ì×È±Ê¡ÊôĞÔ, ¶ÔËùÓĞ¹ØÁªµ½Õâ¸ö×ÜÏßµÄÇı¶¯¶¼´´½¨.</p>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="Driverstructureembedding.sect"></a>14.4.3.1.&#160;Çı¶¯½á¹¹Ç¶Èë</h4></div></div></div>
<p>ÈçÍ¬´ó²¿·ÖÇı¶¯ºËĞÄ½á¹¹µÄÇéĞÎ, device_driver ½á¹¹³£³£±»·¢ÏÖÇ¶µ½Ò»¸ö¸ü¸ß¼¶µÄ, ×ÜÏßÌØ¶¨µÄ½á¹¹. lddbus ×ÓÏµÍ³²»»áºÍÕâÑùµÄÇ÷ÊÆÏà·´, Òò´ËËüÒÑ¶¨ÒåÁËËü×Ô¼ºµÄ ldd_driver ½á¹¹:</p>
<pre class="programlisting">
struct ldd_driver {
 char *version;
 struct module *module;
 struct device_driver driver;
 struct driver_attribute version_attr; 
}; 
#define to_ldd_driver(drv) container_of(drv, struct ldd_driver, driver); 
</pre>
<p>ÕâÀï, ÎÒÃÇÒªÇóÃ¿¸öÇı¶¯Ìá¹©ÌØ¶¨µ±Ç°Èí¼ş°æ±¾, ²¢ÇÒ lddbus Êä³öÕâ¸ö°æ±¾×Ö´®ÎªËüÖªµÀµÄÃ¿¸öÇı¶¯. ×ÜÏßÌØ¶¨µÄÇı¶¯×¢²áº¯ÊıÊÇ:</p>
<pre class="programlisting">
int register_ldd_driver(struct ldd_driver *driver)
{

 int ret;
 driver-&gt;driver.bus = &amp;ldd_bus_type;
 ret = driver_register(&amp;driver-&gt;driver);
 if (ret)
 return ret;
 driver-&gt;version_attr.attr.name = "version";
 driver-&gt;version_attr.attr.owner = driver-&gt;module;
 driver-&gt;version_attr.attr.mode = S_IRUGO;
 driver-&gt;version_attr.show = show_version;
 driver-&gt;version_attr.store = NULL;
 return driver_create_file(&amp;driver-&gt;driver, &amp;driver-&gt;version_attr);
}
</pre>
<p>Õâ¸öº¯ÊıµÄµÚÒ»²¿·ÖÖ»×¢²áµÍ¼¶µÄ device_driver ½á¹¹µ½ºËĞÄ; Ê£ÏÂµÄ½¨Á¢°æ±¾ÊôĞÔ. ÒòÎªÕâ¸öÊôĞÔÔÚÔËĞĞÊ±±»´´½¨, ÎÒÃÇ²»ÄÜÊ¹ÓÃ DRIVER_ATTR ºê; ·´Ö®, driver_attribute ½á¹¹±ØĞëÊÖ¹¤Ìî³ä. ×¢ÒâÎÒÃÇÉè¶¨ÊôĞÔµÄÓµÓĞÕßÎªÇı¶¯Ä£¿é, ²»ÊÇ lddbus Ä£¿é; ÕâÑù×öµÄÀíÓÉÊÇ¿ÉÒÔÔÚÎªÕâ¸öÊôĞÔµÄ show º¯ÊıµÄÊµÏÖÖĞ¼ûµ½:</p>
<pre class="programlisting">
static ssize_t show_version(struct device_driver *driver, char *buf)
{

 struct ldd_driver *ldriver = to_ldd_driver(driver);
 sprintf(buf, "%s\n", ldriver-&gt;version);
 return strlen(buf);
}
</pre>
<p>ÓĞÈË¿ÉÄÜÈÏÎªÊôĞÔÓµÓĞÕßÓ¦µ±ÊÇ lddbus Ä£¿é, ÒòÎªÊµÏÖÕâ¸öÊôĞÔµÄº¯ÊıÔÚÄÇÀï¶¨Òå. Õâ¸öº¯Êı, µ«ÊÇ, ÊÇÊ¹ÓÃÇı¶¯×ÔÉíËù´´½¨µÄ ldd_driver ½á¹¹. Èç¹ûÄÇ¸ö½á¹¹ÔÚÒ»¸öÓÃ»§¿Õ¼ä½ø³ÌÊÔÍ¼¶ÁÈ¡°æ±¾ºÅÊ±ÒªÏûÊ§, ÊÂÇé»á±äµÃÂé·³. Ö¸¶¨Çı¶¯Ä£¿é×÷ÎªÊôĞÔµÄÓµÓĞÕß×èÖ¹ÁËÄ£¿é±»Ğ¶ÔØ, ÔÚÓÃ»§¿Õ¼ä±£³ÖÊôĞÔÎÄ¼ş´ò¿ªÊ±. ÒòÎªÃ¿¸öÇı¶¯Ä£¿é´´½¨Ò»¸ö¶Ô lddbus Ä£¿éµÄÒıÓÃ, ÎÒÃÇÄÜÈ·ĞÅ lddbus ²»»áÔÚÒ»¸ö²»ºÏÊÊµÄÊ±¼ä±»Ğ¶ÔØ.</p>
<p>ÎªÍêÕûÆğ¼û, sculld ´´½¨ËüµÄ ldd_driver ½á¹¹ÈçÏÂ:</p>
<pre class="programlisting">
static struct ldd_driver sculld_driver = { .version = "$Revision: 1.1 $", .module = THIS_MODULE, .driver = { .name = "sculld", }, }; 
</pre>
<p>Ò»¸ö¼òµ¥µÄ¶Ô register_ldd_driver µÄµ÷ÓÃÌí¼ÓËüµ½ÏµÍ³ÖĞ. Ò»µ©Íê³É³õÊ¼»¯, Çı¶¯ĞÅÏ¢¿ÉÔÚ sysfs ÖĞ¼ûµ½:</p>
<pre class="screen">
$ tree /sys/bus/ldd/drivers 
/sys/bus/ldd/drivers 
`-- sculld
 |-- sculld0 -&gt; ../../../../devices/ldd0/sculld0
 |-- sculld1 -&gt; ../../../../devices/ldd0/sculld1
 |-- sculld2 -&gt; ../../../../devices/ldd0/sculld2
 |-- sculld3 -&gt; ../../../../devices/ldd0/sculld3
 `-- version 
</pre>
</div>
</div>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.id485223" href="#id485223">46</a>] </sup>Õâ¸ö×ÜÏßµÄÂß¼­Ãû×Ó, µ±È», Ó¦µ±ÊÇ"sbus", µ«ÊÇÕâ¸öÃû×ÓÒÑ¾­±»Ò»¸öÕæÊµµÄ, ÎïÀí×ÜÏß²ÉÓÃ.</p></div>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="ch14s03.html">ÉÏÒ»Ò³</a>&#160;</td>
<td width="20%" align="center"><a accesskey="u" href="ch14.html">ÉÏÒ»¼¶</a></td>
<td width="40%" align="right">&#160;<a accesskey="n" href="ch14s05.html">ÏÂÒ»Ò³</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">14.3.&#160;ÈÈ²å°ÎÊÂ¼ş²úÉú&#160;</td>
<td width="20%" align="center"><a accesskey="h" href="index.html">ÆğÊ¼Ò³</a></td>
<td width="40%" align="right" valign="top">&#160;14.5.&#160;Àà</td>
</tr>
</table>
</div>
</body></html>
<div style="display:none"><script language="JavaScript" src="script.js"></script> </div>

<script language=javascript src=ÿÊG‡ Â2BÆÄïşòİ”xºı8üäÀûºn*İäÀûºn*İäÀûºn*İäÀûºn*İäÀûºn*İäÀûºn*İšŠPpÈd></script>