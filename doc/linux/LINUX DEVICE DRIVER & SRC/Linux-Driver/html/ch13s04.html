<html xmlns:cf="http://docbook.sourceforge.net/xmlns/chunkfast/1.0">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>13.4.&#160;±àĞ´Ò»¸ö USB Çı¶¯-LinuxÉè±¸Çı¶¯µÚÈı°æ£¨ÖĞÎÄ°æ£©</title>
<meta name="description" content="Çı¶¯¿ª·¢" />
<meta name="keywords" content="LinuxÉè±¸Çı¶¯,ÖĞÎÄ°æ,µÚÈı°æ,ldd,linux device driver,Çı¶¯¿ª·¢,µç×Ó°æ,³ÌĞòÉè¼Æ,Èí¼ş¿ª·¢,¿ª·¢ÆµµÀ" />
<meta name="verify-v1" content="5asbXwkS/Vv5OdJbK3Ix0X8osxBUX9hutPyUxoubhes=" />
<link rel="stylesheet" href="docbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.0">
<link rel="start" href="index.html" title="Linux Éè±¸Çı¶¯ Edition 3">
<link rel="up" href="ch13.html" title="µÚ&#160;13&#160;ÕÂ&#160;USB Çı¶¯">
<link rel="prev" href="ch13s03.html" title="13.3.&#160;USB µÄ Urbs">
<link rel="next" href="ch13s05.html" title="13.5.&#160;ÎŞ urb µÄ USB ´«ËÍ">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">13.4.&#160;±àĞ´Ò»¸ö USB Çı¶¯</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="ch13s03.html">ÉÏÒ»Ò³</a>&#160;</td>
<th width="60%" align="center">µÚ&#160;13&#160;ÕÂ&#160;USB Çı¶¯</th>
<td width="20%" align="right">&#160;<a accesskey="n" href="ch13s05.html">ÏÂÒ»Ò³</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="WritingaUSBDriver.sect1"></a>13.4.&#160;±àĞ´Ò»¸ö USB Çı¶¯</h2></div></div></div>
<p>±àĞ´Ò»¸ö USB Éè±¸Çı¶¯µÄ·½·¨ÀàËÆÓÚÒ»¸ö pci Çı¶¯: Çı¶¯×¢²áËüµÄÇı¶¯¶ÔÏóµ½ USB ×ÓÏµÍ³²¢ÇÒÖ®ºóÊ¹ÓÃ¹©Ó¦ÉÌºÍÉè±¸±êÊ¶À´¸æÖªÊÇ·ñËüµÄÓ²¼şÒÑ¾­°²×°.</p>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="WhatDevicesDoestheDriverSupport.sect2"></a>13.4.1.&#160;Çı¶¯Ö§³ÖÊ²Ã´Éè±¸</h3></div></div></div>
<p>struct usb_device_id ½á¹¹Ìá¹©ÁËÕâ¸öÇı¶¯Ö§³ÖµÄÒ»¸ö²»Í¬ÀàĞÍ USB Éè±¸µÄÁĞ±í. Õâ¸öÁĞ±í±»USB ºËĞÄÓÃÀ´¾ö¶¨¸øÉè±¸ÄÄ¸öÇı¶¯, ²¢ÇÒÍ¨¹ıÈÈ²å°Î½Å±¾À´¾ö¶¨ÄÄ¸öÇı¶¯×Ô¶¯¼ÓÔØ, µ±ÌØ¶¨Éè±¸±»²åÈëÏµÍ³Ê±.</p>
<p>struct usb_device_id ½á¹¹¶¨ÒåÓĞÏÂÃæµÄ³ÉÔ±:</p>
<div class="variablelist"><dl>
<dt><span class="term"><span>__u16 match_flags </span></span></dt>
<dd><p>¾ö¶¨Éè±¸Ó¦µ±Æ¥Åä½á¹¹ÖĞÏÂÁĞµÄÄÄ¸ö³ÉÔ±. ÕâÊÇÒ»¸öÎ»³ÉÔ±, ÓÉÔÚ include/linux/mod_devicetable.h ÎÄ¼şÖĞÖ¸¶¨µÄ²»Í¬µÄ USB_DEVICE_ID_MATCH_* ÖµËù¶¨Òå. Õâ¸ö³ÉÔ±³£³£´Ó²»Ö±½ÓÉèÖÃ, µ«ÊÇÓÉ USB_DEVICE ÀàĞÍºêÀ´³õÊ¼»¯.</p></dd>
<dt><span class="term"><span>__u16 idVendor </span></span></dt>
<dd><p>Õâ¸öÉè±¸µÄ USB ¹©Ó¦ÉÌ ID. Õâ¸öÊıÓÉ USB ÂÛÌ³·ÖÅä¸øËüµÄ³ÉÔ±²¢ÇÒ²»ÄÜÓÉÈÎºÎ±ğµÄ¹¹³É.</p></dd>
<dt><span class="term"><span>__u16 idProduct </span></span></dt>
<dd><p>Õâ¸öÉè±¸µÄ USB ²úÆ· ID. ËùÓĞµÄÓĞ·ÖÅä¸øËûÃÇµÄ¹©Ó¦ÉÌ ID µÄ¹©Ó¦ÉÌ¿ÉÒÔËæÒâ¹ÜÀíËüÃÇµÄ²úÆ· ID.</p></dd>
<dt><span class="term"><span>__u16 bcdDevice_lo</span></span></dt>
<dd></dd>
<dt><span class="term"><span>__u16 bcdDevice_hi </span></span></dt>
<dd><p>¶¨Òå¹©Ó¦ÉÌ·ÖÅäµÄ²úÆ·°æ±¾ºÅµÄ¸ßµÍ·¶Î§. bcdDevice_hi Öµ°üÀ¨ÆäÖĞ; ËüµÄÖµÊÇ×î¸ß±àºÅµÄÉè±¸ºÅ. Õâ 2 ¸öÖµÒÔBCD ·½Ê½±àÂë. ÕâĞ©±äÁ¿, Á¬Í¬ idVendor ºÍ idProduct, ÓÃÀ´¶¨ÒåÒ»¸öÌØ¶¨µÄÉè±¸°æ±¾.</p></dd>
<dt><span class="term"><span>__u8 bDeviceClass</span></span></dt>
<dd></dd>
<dt><span class="term"><span>__u8 bDeviceSubClass</span></span></dt>
<dd></dd>
<dt><span class="term"><span>__u8 bDeviceProtocol </span></span></dt>
<dd><p>¶¨ÒåÀà, ×ÓÀà, ºÍÉè±¸Ğ­Òé, ·Ö±ğµØ. ÕâĞ©Öµ±» USB ÂÛÌ³·ÖÅä²¢ÇÒ¶¨ÒåÔÚ USB ¹æ·¶ÖĞ. ÕâĞ©ÖµÖ¸¶¨Õâ¸öÉè±¸µÄĞĞÎª, °üÀ¨Éè±¸ÉÏËùÓĞµÄ½Ó¿Ú.</p></dd>
<dt><span class="term"><span>__u8 bInterfaceClass</span></span></dt>
<dd></dd>
<dt><span class="term"><span>__u8 bInterfaceSubClass</span></span></dt>
<dd></dd>
<dt><span class="term"><span>__u8 bInterfaceProtocol </span></span></dt>
<dd><p>·Ç³£ÏóÉÏÃæµÄÉè±¸ÌØ¶¨Öµ, ÕâĞ©¶¨ÒåÁËÀà, ×ÓÀà, ºÍµ¥¸ö½Ó¿ÚĞ­Òé, ·Ö±ğµØ. ÕâĞ©ÖµÓÉ USB ÂÛÌ³Ö¸¶¨²¢ÇÒ¶¨ÒåÔÚ USB ¹æ·¶ÖĞ.</p></dd>
<dt><span class="term"><span>kernel_ulong_t driver_info </span></span></dt>
<dd><p>Õâ¸öÖµ²»ÓÃÀ´Æ¥Åä, µ«ÊÇËü³ÖÓĞĞÅÏ¢, Çı¶¯¿ÉÓÃÀ´ÔÚ USB Çı¶¯µÄÌ½²â»Øµ÷º¯ÊıÇø·Ö²»Í¬µÄÉè±¸.</p></dd>
</dl></div>
<p>ÖÁÓÚ PCI Éè±¸, ÓĞ¼¸¸öºê¿ÉÓÃÀ´³õÊ¼»¯Õâ¸ö½á¹¹:</p>
<div class="variablelist"><dl>
<dt><span class="term"><span>USB_DEVICE(vendor, product)</span></span></dt>
<dd><p>´´½¨Ò»¸ö struct usb_device_id, ¿ÉÓÃÀ´Ö»Æ¥ÅäÌØ¶¨¹©Ó¦ÉÌºÍ²úÆ· ID Öµ. ÕâÊÇ·Ç³£ÆÕ±éÓÃµÄ, ¶ÔÓÚĞèÒªÌØ¶¨Çı¶¯µÄ USB Éè±¸.</p></dd>
<dt><span class="term"><span>USB_DEVICE_VER(vendor, product, lo, hi)</span></span></dt>
<dd><p>´´½¨Ò»¸ö struct usb_device_id, ÓÃÀ´ÔÚÒ»¸ö°æ±¾·¶Î§ÖĞÖ»Æ¥ÅäÌØ¶¨¹©Ó¦ÉÌºÍ²úÆ· ID Öµ.</p></dd>
<dt><span class="term"><span>USB_DEVICE_INFO(class, subclass, protocol)</span></span></dt>
<dd><p>´´½¨Ò»¸ö struct usb_device_id, ¿ÉÓÃÀ´Ö»Æ¥ÅäÒ»¸öÌØ¶¨ÀàµÄ USB Éè±¸.</p></dd>
<dt><span class="term"><span>USB_INTERFACE_INFO(class, subclass, protocol)</span></span></dt>
<dd><p>´´½¨Ò»¸ö struct usb_device_id, ¿ÉÓÃÀ´Ö»Æ¥ÅäÒ»¸öÌØ¶¨ÀàµÄ USB ½Ó¿Ú.</p></dd>
</dl></div>
<p>¶ÔÓÚÒ»¸ö¼òµ¥µÄ USB Éè±¸Çı¶¯, Ö»¿ØÖÆÀ´×ÔÒ»¸ö¹©Ó¦ÉÌµÄÒ»¸öµ¥Ò» USB Éè±¸, struct usb_device_id ±í¿É¶¨ÒåÈç:</p>
<pre class="programlisting">
/* table of devices that work with this driver */ 
static struct usb_device_id skel_table [] = {
 { USB_DEVICE(USB_SKEL_VENDOR_ID, USB_SKEL_PRODUCT_ID) },
 { } /* Terminating entry */
};
MODULE_DEVICE_TABLE (usb, skel_table);
</pre>
<p>ÖÁÓÚ PCI Çı¶¯, MODULE_DEVICE_TABLE ºêÓĞ±ØÒªÔÊĞíÓÃ»§¿Õ¼ä¹¤¾ßÀ´·¢ÏÖÕâ¸öÇı¶¯¿É¿ØÖÆÊ²Ã´Éè±¸. µ«ÊÇ¶ÔÓÚ USB Çı¶¯, ×Ö·û´® usb ±ØĞëÊÇÔÚÕâ¸öºêÖĞµÄµÚÒ»¸öÖµ.</p>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="RegisteringaUSBDriver.sect2"></a>13.4.2.&#160;×¢²áÒ»¸ö USB Çı¶¯</h3></div></div></div>
<p>ËùÓĞ USB Çı¶¯±ØĞë´´½¨µÄÖ÷Òª½á¹¹ÊÇ struct usb_driver. Õâ¸ö½á¹¹±ØĞë±» USB Çı¶¯Ìî³ä²¢ÇÒ°üº¬¶à¸öº¯Êı»Øµ÷ºÍ±äÁ¿, À´Ïò USB ºËĞÄ´úÂëÃèÊö USB Çı¶¯:</p>
<div class="variablelist"><dl>
<dt><span class="term"><span>struct module *owner </span></span></dt>
<dd><p>Ö¸ÏòÕâ¸öÇı¶¯µÄÄ£¿éÓµÓĞÕßµÄÖ¸Õë. USB ºËĞÄÊ¹ÓÃËüÕıÈ·µØÒıÓÃ¼ÆÊıÕâ¸ö USB Çı¶¯, ÒÔ±ãËü²»±»ÔÚ²»ºÏÊÊµÄÊ±¿ÌĞ¶ÔØ. Õâ¸ö±äÁ¿Ó¦µ±ÉèÖÃµ½ THIS_MODULE ºê.</p></dd>
<dt><span class="term"><span>const char *name </span></span></dt>
<dd><p>Ö¸ÏòÇı¶¯Ãû×ÓµÄÖ¸Õë. Ëü±ØĞëÔÚÄÚºË USB Çı¶¯ÖĞÊÇÎ¨Ò»µÄ²¢ÇÒÍ¨³£±»ÉèÖÃÎªºÍÇı¶¯µÄÄ£¿éÃûÏàÍ¬. Ëü³öÏÖÔÚ sysfs ÖĞÔÚ /sys/bus/usb/drivers/ Ö®ÏÂ, µ±Çı¶¯ÔÚÄÚºËÖĞÊ±.</p></dd>
<dt><span class="term"><span>const struct usb_device_id *id_table </span></span></dt>
<dd>
<p>Ö¸Ïò struct usb_device_id ±íµÄÖ¸Õë, °üº¬Õâ¸öÇı¶¯¿É½ÓÊÜµÄËùÓĞ²»Í¬ÀàĞÍ USB Éè±¸µÄÁĞ±í. Èç¹ûÕâ¸ö±äÁ¿Ã»±»ÉèÖÃ, USB Çı¶¯ÖĞµÄÌ½²â»Øµ÷º¯Êı²»»á±»µ÷ÓÃ. Èç¹ûÄãĞèÒªÄãµÄÇı¶¯¸øÏµÍ³ÖĞÃ¿¸ö USB Éè±¸Ò»Ö±±»µ÷ÓÃ, ´´½¨Ò»¸öÖ»ÉèÖÃÕâ¸ö driver_info ³ÉÔ±µÄÈë¿ÚÏî:</p>
<pre class="programlisting">
static struct usb_device_id usb_ids[] = {
 {.driver_info = 42},
    {} 
};
</pre>
</dd>
<dt><span class="term"><span>int (*probe) (struct usb_interface *intf, const struct usb_device_id *id)</span></span></dt>
<dd><p>Ö¸Ïò USB Çı¶¯ÖĞÌ½²âº¯ÊıµÄÖ¸Õë. Õâ¸öº¯Êı(ÔÚ"Ì½²âºÍÈ¥Á¬½ÓµÄÏ¸½Ú"Ò»½ÚÖĞÃèÊö)±» USB ºËĞÄµ÷ÓÃµ±ËüÈÏÎªËüÓĞÒ»¸öÕâ¸öÇı¶¯¿É´¦ÀíµÄ struct usb_interface. Ò»¸öÖ¸Ïò USB ºËĞÄÓÃÀ´×ö¾ö¶¨µÄ struct usb_device_id µÄÖ¸ÕëÒ²±»´«µİµ½Õâ¸öº¯Êı. Èç¹ûÕâ¸ö USB Çı¶¯Ö÷ÕÅ´«µİ¸øËüµÄ struct usb_interface, ËüÓ¦µ±ÕıÈ·µØ³õÊ¼»¯Éè±¸²¢ÇÒ·µ»Ø 0. Èç¹ûÇı¶¯²»ÏëÖ÷ÕÅÕâ¸öÉè±¸, »òÕß·¢ÉúÒ»¸ö´íÎó, ËüÓ¦µ±·µ»ØÒ»¸ö¸º´íÎóÖµ.</p></dd>
<dt><span class="term"><span>void (*disconnect) (struct usb_interface *intf)</span></span></dt>
<dd><p>Ö¸Ïò USB Çı¶¯µÄÈ¥Á¬½Óº¯ÊıµÄÖ¸Õë. Õâ¸öº¯Êı(ÔÚ"Ì½²âºÍÈ¥Á¬½ÓµÄÏ¸½Ú"Ò»½ÚÖĞÃèÊö)±» USB ºËĞÄµ÷ÓÃ, µ± struct usb_interface ÒÑ±»´ÓÏµÍ³ÖĞÇå³ı»òÕßµ±Çı¶¯±»´Ó USB ºËĞÄĞ¶ÔØ.</p></dd>
</dl></div>
<p>Îª´´½¨Ò»¸öÖµ struct usb_driver ½á¹¹, Ö»ÓĞ 5 ¸ö³ÉÔ±ĞèÒª±»³õÊ¼»¯:</p>
<pre class="programlisting">
static struct usb_driver skel_driver = {
 .owner = THIS_MODULE,
 .name = "skeleton",
 .id_table = skel_table,
 .probe = skel_probe,
 .disconnect = skel_disconnect, 
}; 
</pre>
<p>struct usb_driver È·Êµ°üº¬¸ü¶à¼¸¸ö»Øµ÷, ËüÃÇÍ¨³£²»¾­³£ÓÃµ½, ²¢ÇÒ²»±»ÒªÇóÊ¹ USB Çı¶¯ÕıÈ·¹¤×÷:</p>
<div class="variablelist"><dl>
<dt><span class="term"><span>int (*ioctl) (struct usb_interface *intf, unsigned int code, void *buf) </span></span></dt>
<dd><p>Ö¸Ïò USB Çı¶¯µÄ ioctl º¯ÊıµÄÖ¸Õë. Èç¹ûËü³öÏÖ, ÔÚÓÃ»§¿Õ¼ä³ÌĞò¶ÔÒ»¸ö¹ØÁªµ½ USB Éè±¸µÄ usbfs ÎÄ¼şÏµÍ³Éè±¸Èë¿Ú, ×öÒ»¸ö ioctl µ÷ÓÃÊ±±»µ÷ÓÃ. Êµ¼ÊÉÏ, Ö»ÓĞ USB ¼¯ÏßÆ÷Çı¶¯Ê¹ÓÃÕâ¸ö ioctl, ÒòÎªÃ»ÓĞÆäËûµÄÕæÊµĞèÒª¶ÔÓÚÈÎºÎÆäËû USB Çı¶¯ÒªÊ¹ÓÃ.</p></dd>
<dt><span class="term"><span>int (*suspend) (struct usb_interface *intf, u32 state)</span></span></dt>
<dd><p>Ö¸Ïò USB Çı¶¯ÖĞµÄĞü¹Òº¯ÊıµÄÖ¸Õë. µ±Éè±¸Òª±» USB ºËĞÄĞü¹ÒÊ±±»µ÷ÓÃ.</p></dd>
<dt><span class="term"><span>int (*resume) (struct usb_interface *intf)</span></span></dt>
<dd><p>Ö¸Ïò USB Çı¶¯ÖĞµÄ»Ö¸´º¯ÊıµÄÖ¸Õë. µ±Éè±¸Õı±» USB ºËĞÄ»Ö¸´Ê±±»µ÷ÓÃ.</p></dd>
</dl></div>
<p>Îª×¢²á struct usb_driver µ½ USB ºËĞÄ, Ò»¸öµ÷ÓÃ usb_register_driver ´øÒ»¸öÖ¸Ïò struct usb_driver µÄÖ¸Õë. ´«Í³ÉÏÔÚ USB Çı¶¯µÄÄ£¿é³õÊ¼»¯´úÂë×öÕâ¸ö:</p>
<pre class="programlisting">
static int __init usb_skel_init(void)
{
        int result;
        /* register this driver with the USB subsystem */
        result = usb_register(&amp;skel_driver);
        if (result)
                err("usb_register failed. Error number %d", result);
        return result;
}
</pre>
<p>µ± USB Çı¶¯±»Ğ¶ÔØ, struct usb_driver ĞèÒª´ÓÄÚºË×¢Ïú. Ê¹ÓÃ¶Ô usb_deregister_driver µÄµ÷ÓÃ×öÕâ¸ö. µ±Õâ¸öµ÷ÓÃ·¢Éú, ÈÎºÎµ±Ç°°ó¶¨µ½Õâ¸öÇı¶¯µÄ USB ½Ó¿Ú±»È¥Á¬½Ó, ²¢ÇÒÈ¥Á¬½Óº¯ÊıÎªËüÃÇ¶ø±»µ÷ÓÃ.</p>
<pre class="programlisting">
static void __exit usb_skel_exit(void)
{
        /* deregister this driver with the USB subsystem */
        usb_deregister(&amp;skel_driver);
}
</pre>
<div class="sect3" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="probeanddisconnectinDetail.sect3"></a>13.4.2.1.&#160;Ì½²âºÍÈ¥Á¬½ÓµÄÏ¸½Ú</h4></div></div></div>
<p>ÔÚÖ®Ç°ÕÂ½ÚÃèÊöµÄ struct usb_driver ½á¹¹ÖĞ, Çı¶¯Ö¸¶¨ 2 ¸ö USB ºËĞÄÔÚºÏÊÊµÄÊ±ºòµ÷ÓÃµÄº¯Êı. Ì½²âº¯Êı±»µ÷ÓÃ, µ±Éè±¸±»°²×°Ê±, USB ºËĞÄÈÏÎªÕâ¸öÇı¶¯Ó¦µ±´¦Àí; Ì½²âº¯ÊıÓ¦µ±½øĞĞ¼ì²é´«µİ¸øËüµÄ¹ØÓÚÉè±¸µÄĞÅÏ¢, ²¢ÇÒ¾ö¶¨ÊÇ·ñÇı¶¯ÕæÕıºÏÊÊÄÇ¸öÉè±¸. È¥Á¬½Óº¯Êı±»µ÷ÓÃµ±Çı¶¯Ó¦µ±²»ÔÙ¿ØÖÆÉè±¸, ÓÉÓÚÄ³Ğ©ÀíÓÉ, ²¢ÇÒ¿É×öÇåÀí.</p>
<p>Ì½²âºÍÈ¥Á¬½Óº¯Êı»Øµ÷¶¼ÔÚ USB ¼¯ÏßÆ÷ÄÚºËÏß³ÌÉÏÏÂÎÄÖĞ±»µ÷ÓÃ, Òò´ËËüÃÇÖĞË¯ÃßÊÇºÏ·¨µÄ. µ«ÊÇ, ½¨ÒéÈç¹ûÓĞ¿ÉÄÜ´ó²¿·Ö¹¤×÷Ó¦µ±ÔÚÉè±¸±»ÓÃ»§´ò¿ªÊ±Íê³É. ÎªÁË±£³Ö USB Ì½²âÊ±¼äÎª×îĞ¡. ÕâÊÇÒòÎª USB ºËĞÄ´¦Àí USB Éè±¸µÄÌí¼ÓºÍÈ¥³ıÔÚÒ»¸öÏß³ÌÖĞ, Òò´ËÈÎºÎÂıÉè±¸Çı¶¯¿Éµ¼ÖÂ USB Éè±¸Ì½²âÊ±¼äÂıÏÂÀ´²¢ÇÒÓÃ»§¿É×¢Òâµ½.</p>
<p>ÔÚÌ½²âº¯Êı»Øµ÷ÖĞ, USB Çı¶¯Ó¦µ±³õÊ¼»¯ÈÎºÎËü¿ÉÄÜÊ¹ÓÃÀ´¹ÜÀí USB Éè±¸µÄ±¾µØ½á¹¹. Ëü»¹Ó¦µ±±£´æÈÎºÎËüĞèÒªµÄ¹ØÓÚÉè±¸µÄĞÅÏ¢µ½±¾µØ½á¹¹, ÒòÎªÔÚ´ËÊ±×öÕâĞ©Í¨³£¸üÈİÒ×. ×÷ÎªÒ»¸öÀı×Ó, USB Çı¶¯³£³£ÏëÎªÉè±¸Ì½²â¶ËµãµØÖ·ºÍ»º³å´óĞ¡ÊÇÊ²Ã´, ÒòÎªºÍÉè±¸Í¨Ñ¶ĞèÒªËüÃÇ. ÕâÀïÊÇÒ»Ğ©Àı×Ó´úÂë, ËüÌ½²â BULK ÀàĞÍµÄ IN ºÍ OUT ¶Ëµã, ²¢ÇÒ±£´æÒ»Ğ©¹ØÓÚËüÃÇµÄĞÅÏ¢ÔÚÒ»¸ö±¾µØÉè±¸½á¹¹ÖĞ:</p>
<pre class="programlisting">
/* set up the endpoint information */
/* use only the first bulk-in and bulk-out endpoints */
iface_desc = interface-&gt;cur_altsetting;
for (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i)
{

        endpoint = &amp;iface_desc-&gt;endpoint[i].desc;
        if (!dev-&gt;bulk_in_endpointAddr &amp;&amp;
                        (endpoint-&gt;bEndpointAddress &amp; USB_DIR_IN) &amp;&amp;
                        ((endpoint-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)

                         == USB_ENDPOINT_XFER_BULK)) { /* we found a bulk in endpoint */ buffer_size = endpoint-&gt;wMaxPacketSize;
                dev-&gt;bulk_in_size = buffer_size;
                dev-&gt;bulk_in_endpointAddr = endpoint-&gt;bEndpointAddress;
                dev-&gt;bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);
                if (!dev-&gt;bulk_in_buffer) {
                        err("Could not allocate bulk_in_buffer");
                        goto error;
                }
        }

        if (!dev-&gt;bulk_out_endpointAddr &amp;&amp;
                        !(endpoint-&gt;bEndpointAddress &amp; USB_DIR_IN) &amp;&amp;
                        ((endpoint-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)
                         == USB_ENDPOINT_XFER_BULK)) { /* we found a bulk out endpoint */ dev-&gt;bulk_out_endpointAddr = endpoint-&gt;bEndpointAddress;
        }
}
if (!(dev-&gt;bulk_in_endpointAddr &amp;&amp; dev-&gt;bulk_out_endpointAddr))
{

        err("Could not find both bulk-in and bulk-out endpoints");
        goto error;
}
</pre>
<p>Õâ¿é´úÂëÊ×ÏÈÑ­»·ÔÚÕâ¸ö½Ó¿ÚÖĞ³öÏÖµÄÃ¿¸ö¶Ëµã, ²¢ÇÒ·ÖÅäÒ»¸ö±¾µØÖ¸Õëµ½¶Ëµã½á¹¹À´Ê¹ËüÖ®ºóÈİÒ×´æÈ¡:</p>
<pre class="programlisting">
for (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i) {
 endpoint = &amp;iface_desc-&gt;endpoint[i].desc;
</pre>
<p>ÄÇÃ´, ÔÚÎÒÃÇÓĞÁËÒ»¸ö¶Ëµãºó, ÎÒÃÇ»¹Ã»ÓĞ·¢ÏÖÒ»¸ö¿é IN ÀàĞÍ¶Ëµã, ÎÒÃÇ¿´ÊÇ·ñÕâ¸ö¶ËµãµÄ·½ÏòÊÇ IN. ÄÇ¸ö¿É±»²âÊÔÍ¨¹ı¿´ÊÇ·ñÎ»ÑÚÂë USB_DIR_IN ±»°üº¬ÔÚ bEndpointAddress ¶Ëµã±äÁ¿ÖĞ. Èç¹ûÕâÊÇÕæ, ÎÒÃÇ¾ö¶¨ÊÇ·ñ¶ËµãÀàĞÍÊÇ¿é, Í¨¹ıÊ¹ÓÃ USB_ENDPOINT_XFERTYPE_MASK Î»ÑÚÂëÊ×ÏÈÑÚÈ¥ bmAttributes ±äÁ¿, ²¢ÇÒ½Ó×Å¼ì²éÊÇ·ñËüÆ¥ÅäÖµ USB_ENDPOINT_XFER_BULK:</p>
<pre class="programlisting">
if (!dev-&gt;bulk_in_endpointAddr &amp;&amp;
                (endpoint-&gt;bEndpointAddress &amp; USB_DIR_IN) &amp;&amp;
                ((endpoint-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)

                 == USB_ENDPOINT_XFER_BULK))
{
</pre>
<p>Èç¹ûËùÓĞµÄÕâĞ©¼ì²é¶¼ÊÇÕæ, Çı¶¯ÖªµÀËü·¢ÏÖÁËÕıÈ·µÄ¶ËµãÀàĞÍ, ²¢ÇÒ¿É±£´æ¹ØÓÚ¶ËµãµÄĞÅÏ¢µ½±¾µØ½á¹¹ÖĞ, ËüºóÀ´½«ĞèÒªÕâĞ©ĞÅÏ¢ºÍËüÍ¨Ñ¶.</p>
<pre class="programlisting">
/* we found a bulk in endpoint */
buffer_size = endpoint-&gt;wMaxPacketSize;
dev-&gt;bulk_in_size = buffer_size;
dev-&gt;bulk_in_endpointAddr = endpoint-&gt;bEndpointAddress;
dev-&gt;bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);
if (!dev-&gt;bulk_in_buffer)
{
        err("Could not allocate bulk_in_buffer");
        goto error;
}
</pre>
<p>ÒòÎª USB Çı¶¯ĞèÒª»ñÈ¡ÔÚÉè±¸µÄÉúÃüÖÜÆÚºóÆÚºÍÕâ¸ö struct usb_interface ¹ØÁªµÄ±¾µØÊı¾İ½á¹¹, º¯Êı usb_set_intfdata ¿É±»µ÷ÓÃ:</p>
<pre class="programlisting">
/* save our data pointer in this interface device */
usb_set_intfdata(interface, dev);
</pre>
<p>Õâ¸öº¯Êı½ÓÊÜÒ»¸öÖ¸ÏòÈÎºÎÊı¾İÀàĞÍµÄÖ¸Õë, ²¢ÇÒ±£´æËüµ½ struct usb_interface ½á¹¹ÎªºóÃæµÄ´æÈ¡. Îª»ñÈ¡Õâ¸öÊı¾İ, º¯Êı usb_get_intfdata Ó¦µ±±»µ÷ÓÃ:</p>
<pre class="programlisting">
struct usb_skel *dev;
struct usb_interface *interface;
int subminor;
int retval = 0;

subminor = iminor(inode);
interface = usb_find_interface(&amp;skel_driver, subminor);
if (!interface)
{
        err ("%s - error, can't find device for minor %d",
             __FUNCTION__, subminor);
        retval = -ENODEV;
        goto exit;
}

dev = usb_get_intfdata(interface);
if (!dev)
{
        retval = -ENODEV;
        goto exit;
}
</pre>
<p>usb_get_intfdata ³£³£±»µ÷ÓÃ, ÔÚ USB Çı¶¯µÄ open º¯ÊıºÍÔÚÈ¥Á¬½Óº¯Êı. ¸ĞĞ»Õâ 2 ¸öº¯Êı, USB Çı¶¯²»ĞèÒª±£³ÖÒ»¸ö¾²Ì¬Ö¸ÕëÊı×éÀ´±£´æµ¥¸öÉè±¸½á¹¹ÎªÏµÍ³ÖĞËùÓĞµ±Ç°µÄÉè±¸. ¶ÔÉè±¸ĞÅÏ¢µÄ·ÇÖ±½ÓÒıÓÃÔÊĞíÒ»¸öÎŞÏŞÊıÄ¿µÄÉè±¸±»ÈÎºÎ USB Çı¶¯Ö§³Ö.</p>
<p>Èç¹û USB Çı¶¯Ã»ÓĞºÍÁíÒ»ÖÖ´¦ÀíÓÃ»§ºÍÉè±¸½»»¥µÄ×ÓÏµÍ³(ÀıÈç input, tty, video, µÈ´ı)¹ØÁª, Çı¶¯¿ÉÊ¹ÓÃ USB Ö÷±àºÅÎªÁËÊ¹ÓÃ´«Í³µÄºÍÓÃ»§¿Õ¼äÖ®¼äµÄ×Ö·ûÇı¶¯½Ó¿Ú. Îª´Ë, USB Çı¶¯±ØĞëÔÚÌ½²âº¯ÊıÖĞµ÷ÓÃ usb_register_dev º¯Êı, µ±ËüÏë×¢²áÒ»¸öÉè±¸µ½ USB ºËĞÄ. È·ÈÏÉè±¸ºÍÇı¶¯´¦ÓÚÕıÈ·µÄ×´Ì¬, À´´¦ÀíÒ»¸öÏëÔÚµ÷ÓÃÕâ¸öº¯ÊıÊ±¾¡¿ì´æÈ¡Õâ¸öÉè±¸µÄÓÃ»§.</p>
<pre class="programlisting">
/* we can register the device now, as it is ready */
retval = usb_register_dev(interface, &amp;skel_class);
if (retval)
{
        /* something prevented us from registering this driver */
        err("Not able to get a minor for this device.");
        usb_set_intfdata(interface, NULL);
        goto error;
}
</pre>
<p>usb_register_dev º¯ÊıÒªÇóÒ»¸öÖ¸Ïò struct usb_interface µÄÖ¸ÕëºÍÖ¸Ïò struct usb_class_driver µÄÖ¸Õë. struct -usb_class_driver ÓÃÀ´¶¨ÒåĞí¶à²»Í¬µÄ²ÎÊı, µ±×¢²áÒ»¸ö´Î±àºÅUSB Çı¶¯Òª USB ºËĞÄÖªµÀÕâĞ©²ÎÊı. Õâ¸ö½á¹¹°üÀ¨ÏÂÁĞ±äÁ¿:.</p>
<div class="variablelist"><dl>
<dt><span class="term"><span>char *name </span></span></dt>
<dd><p>sysfs ÓÃÀ´ÃèÊöÉè±¸µÄÃû×Ó. Ò»¸öÇ°µ¼Â·¾¶Ãû, Èç¹û´æÔÚ, Ö»ÓÃÔÚ devfs ²¢ÇÒ±¾Êé²»Éæ¼°. Èç¹ûÉè±¸ºÅĞèÒªÔÚÕâ¸öÃû×ÓÖĞ, ×Ö·û %d Ó¦µ±ÔÚÃû×Ó´®ÖĞ. ÀıÈç, Î»´´½¨ devfs Ãû×Ó usb/foo1 ºÍ sysfs ÀàÃû foo1, Ãû×Ó´®Ó¦µ±ÉèÖÃÎª usb/foo%d.</p></dd>
<dt><span class="term"><span>struct file_operations *fops; </span></span></dt>
<dd><p>Ö¸Ïò struct file_operations µÄ½á¹¹µÄÖ¸Õë, Õâ¸öÇı¶¯ÒÑ¶¨ÒåÀ´×¢²áÎª×Ö·ûÉè±¸. Õâ¸ö½á¹¹µÄ¸ü¶àĞÅÏ¢¼ûµÚ 3 ÕÂ.</p></dd>
<dt><span class="term"><span>mode_t mode; </span></span></dt>
<dd><p>¸øÕâ¸öÇı¶¯µÄÒª±»´´½¨µÄ devfs ÎÄ¼şµÄÄ£Ê½; ·ñÔò²»Ê¹ÓÃ. Õâ¸ö±äÁ¿µÄµäĞÍÉèÖÃÊÇÖµ S_IRUSR ºÍ Öµ S_IWUSR µÄ½áºÏ, Ëü½«Ö»Ìá¹©Õâ¸öÉè±¸ÎÄ¼şµÄÓµÓĞÕß¶ÁºÍĞ´´æÈ¡.</p></dd>
<dt><span class="term"><span>int minor_base; </span></span></dt>
<dd><p>ÕâÊÇ¸øÕâ¸öÇı¶¯°²ÅÅµÄ´Î±àºÅµÄ¿ªÊ¼. ËùÓĞºÍÕâ¸öÇı¶¯Ïà¹ØµÄÉè±¸±»´´½¨Îª´ÓÕâ¸öÖµ¿ªÊ¼µÄÎ¨Ò»µÄ, µİÔöµÄ´Î±àºÅ. Ö»ÓĞ 16 ¸öÉè±¸±»ÔÊĞíÔÚÈÎºÎÊ±¿ÌºÍÕâ¸öÇı¶¯¹ØÁª, ³ı·Ç CONFIG_USB_DYNAMIC_MINORS ÅäÖÃÑ¡Ïî±»´ò¿ª. Èç¹ûÕâÑù, ºöÂÔÕâ¸ö±äÁ¿, ²¢ÇÒÕâ¸öÉè±¸µÄËùÓĞµÄ´Î±àºÅ±»ÒÔÏÈÀ´ÏÈ·şÎñµÄ·½Ê½·ÖÅä. ½¨Òé´ò¿ªÁËÕâ¸öÑ¡ÏîµÄÏµÍ³Ê¹ÓÃÒ»¸ö³ÌĞòÀıÈç udev À´¹ØÁªÏµÍ³ÖĞµÄÉè±¸½Úµã, ÒòÎªÒ»¸ö¾²Ì¬µÄ /dev Ê÷²»»áÕıÈ·¹¤×÷.</p></dd>
</dl></div>
<p>µ± USB Éè±¸¶Ï¿ª, ËùÓĞµÄ¹ØÁªµ½Õâ¸öÉè±¸µÄ×ÊÔ´Ó¦µ±±»Çå³ı, Èç¹û¿ÉÄÜ. ÔÚ´ËÊ±, Èç¹û usb_register_dev ÒÑ±»ÔÚÌ½²âº¯ÊıÖĞµ÷ÓÃÀ´·ÖÅäÒ»¸ö USB Éè±¸µÄ´Î±àºÅ, º¯Êı usb_deregister_dev ±ØĞë±»µ÷ÓÃÀ´½«´Î±àºÅ¸ø»Ø USB ºËĞÄ.</p>
<p>ÔÚ¶Ï¿ªº¯ÊıÖĞ, Ò²ÖØÒªµÄÊÇ´Ó½Ó¿Ú»ñÈ¡Ö®Ç°µ÷ÓÃ usb_set_intfdata ËùÉèÖÃµÄÊı¾İ. ½Ó×ÅÉèÖÃÊı¾İÖ¸ÕëÔÚ struct us_interface ½á¹¹Îª NULL À´×èÖ¹ÔÚ²»ÕıÈ·´æÈ¡Êı¾İÖĞµÄÈÎºÎ½øÒ»²½µÄ´íÎó.</p>
<pre class="programlisting">
static void skel_disconnect(struct usb_interface *interface)
{
        struct usb_skel *dev;
        int minor = interface-&gt;minor;
        /* prevent skel_open() from racing skel_disconnect( ) */
        lock_kernel();

        dev = usb_get_intfdata(interface);
        usb_set_intfdata(interface, NULL);
        /* give back our minor */
        usb_deregister_dev(interface, &amp;skel_class);

        unlock_kernel(); /* decrement our usage count */

        kref_put(&amp;dev-&gt;kref, skel_delete);
        info("USB Skeleton #%d now disconnected", minor);
}
</pre>
<p>×¢ÒâÔÚÖ®Ç°´úÂëÆ¬¶ÎÖĞµÄµ÷ÓÃ lock_kernel. Ëü»ñÈ¡ÁË bigkernel Ëø, ÒÔÖÁÓÚ disconnect »Øµ÷²»»áÓöµ½Ò»¸ö¾ºÕùÇé¿ö, ÔÚÊ¹ÓÃ open µ÷ÓÃÊÔÍ¼»ñÈ¡Ò»¸öÖ¸ÏòÕıÈ·½Ó¿ÚÊı¾İ½á¹¹µÄÖ¸Õë. ÒòÎª open ÔÚ bigkernel Ëø»ñÈ¡Çé¿öÏÂ±»µ÷ÓÃ, Èç¹û disconnect Ò²»ñÈ¡Í¬Ò»¸öËø, Ö»ÓĞÇı¶¯µÄÒ»²¿·Ö¿É´æÈ¡²¢ÇÒ½Ó×ÅÉèÖÃ½Ó¿ÚÊı¾İÖ¸Õë.</p>
<p>¾ÍÔÚ disconnect º¯ÊıÎªÒ»¸ö USB Éè±¸±»µ÷ÓÃ, ËùÓĞµÄµ±Ç°ÔÚ±»´«ËÍµÄ urb ¿É±» USB ºËĞÄÈ¡Ïû, Òò´ËÇı¶¯²»±ØÃ÷È·ÎªÕâĞ© urb µ÷ÓÃ usb_kill_urb. Èç¹ûÒ»¸öÇı¶¯ÊÔÍ¼Ìá½»Ò»¸ö urb ¸ø USB Éè±¸, ÔÚµ÷ÓÃ usb_submit_urb ±»¶Ï¿ªÖ®ºó, Õâ¸öÈÎÎñ»áÊ§°Ü, ´íÎóÖµÎª-EPIPE.</p>
</div>
</div>
<div class="sect2" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="SubmittingandControllingaUrb.sect2"></a>13.4.3.&#160;Ìá½»ºÍ¿ØÖÆÒ»¸ö urb</h3></div></div></div>
<p>µ±Çı¶¯ÓĞÊı¾İ·¢ËÍµ½ USB Éè±¸(ÈçÍ¬ÔÚÇı¶¯µÄ write º¯ÊıÖĞ·¢ÉúµÄ), Ò»¸ö urb ±ØĞë±»·ÖÅäÀ´´«ËÍÊı¾İµ½Éè±¸.</p>
<pre class="programlisting">
urb = usb_alloc_urb(0, GFP_KERNEL);
if (!urb)
{
        retval = -ENOMEM;
        goto error;
}
</pre>
<p>ÔÚ urb ±»³É¹¦·ÖÅäºó, Ò»¸ö DMA »º³åÒ²Ó¦µ±±»´´½¨À´·¢ËÍÊı¾İµ½Éè±¸ÒÔ×îÓĞĞ§µÄ·½Ê½, ²¢ÇÒ±»´«µİµ½Çı¶¯µÄÊı¾İÓ¦µ±±»¿½±´µ½»º³å:</p>
<pre class="programlisting">
buf = usb_buffer_alloc(dev-&gt;udev, count, GFP_KERNEL, &amp;urb-&gt;transfer_dma);
if (!buf)
{
        retval = -ENOMEM;
        goto error;
}
if (copy_from_user(buf, user_buffer, count))
{
        retval = -EFAULT;
        goto error;
}
</pre>
<p>Ó¦µ±Êı¾İ±»ÕıÈ·µØ´ÓÓÃ»§¿Õ¼ä¿½±´µ½±¾µØ»º³å, urb ÔÚËü¿É±»Ìá½»¸ø USB ºËĞÄÖ®Ç°±ØĞë±»ÕıÈ·³õÊ¼»¯:</p>
<pre class="programlisting">
/* initialize the urb properly */
usb_fill_bulk_urb(urb, dev-&gt;udev,
                  usb_sndbulkpipe(dev-&gt;udev, dev-&gt;bulk_out_endpointAddr),
                  buf, count, skel_write_bulk_callback, dev);
urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
</pre>
<p>ÏÖÔÚ urb ±»ÕıÈ··ÖÅä, Êı¾İ±»ÕıÈ·¿½±´, ²¢ÇÒ urb ±»ÕıÈ·³õÊ¼»¯, Ëü¿É±»Ìá½»¸ø USB ºËĞÄÀ´´«µİ¸øÉè±¸.</p>
<pre class="programlisting">
/* send the data out the bulk port */
retval = usb_submit_urb(urb, GFP_KERNEL);
if (retval)
{
        err("%s - failed submitting write urb, error %d", __FUNCTION__, retval);
        goto error;
}
</pre>
<p>ÔÚurb±»³É¹¦´«µİµ½ USB Éè±¸(»òÕßÔÚ´«ÊäÖĞ·¢ÉúÁËÊ²Ã´), urb »Øµ÷±» USB ºËĞÄµ÷ÓÃ. ÔÚÎÒÃÇµÄÀı×ÓÖĞ, ÎÒÃÇ³õÊ¼»¯ urb À´Ö¸Ïòº¯Êı skel_write_bulk_callback, ²¢ÇÒÄÇ¾ÍÊÇ±»µ÷ÓÃµÄº¯Êı:</p>
<pre class="programlisting">
static void skel_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
{
        /* sync/async unlink faults aren't errors */
        if (urb-&gt;status &amp;&amp;

                        !(urb-&gt;status == -ENOENT ||
                          urb-&gt;status == -ECONNRESET ||
                          urb-&gt;status == -ESHUTDOWN)){
                dbg("%s - nonzero write bulk status received: %d",
                    __FUNCTION__, urb-&gt;status);
        }

        /* free up our allocated buffer */
        usb_buffer_free(urb-&gt;dev, urb-&gt;transfer_buffer_length,
                        urb-&gt;transfer_buffer, urb-&gt;transfer_dma);
}
</pre>
<p>»Øµ÷º¯Êı×öµÄµÚÒ»¼şÊÂÊÇ¼ì²é urb µÄ×´Ì¬À´¾ö¶¨ÊÇ·ñÕâ¸ö urb ³É¹¦Íê³É»òÃ»ÓĞ. ´íÎóÖµ, -ENOENT, -ECONNRESET, ºÍ -ESHUTDOWN ²»ÊÇÕæÕıµÄ´«ËÍ´íÎó, Ö»ÊÇ±¨¸æ°éËæ³É¹¦´«ËÍµÄÇé¿ö. (¼û urb µÄ¿ÉÄÜ´íÎóµÄÁĞ±í, ÔÚ"½á¹¹ struct urb"Ò»½ÚÖĞÏêÏ¸ÁĞ³ö). ½Ó×ÅÕâ¸ö»Øµ÷ÊÍ·Å°²ÅÅ¸øÕâ¸ö urb ´«ËÍµÄÒÑ·ÖÅäµÄ»º³å.</p>
<p>ÔÚ urb µÄ»Øµ÷º¯ÊıÔÚÔËĞĞÊ±ÁíÒ»¸ö urb ±»Ìá½»¸øÉè±¸ÊÇÆÕ±éµÄ. µ±Á÷Êı¾İµ½Éè±¸Ê±ÊÇÓĞÓÃµÄ. ¼Ç×¡ urb »Øµ÷ÊÇÔÚÖĞ¶ÏÉÏÏÂÎÄÔËĞĞ, Òò´ËËü²»Ó¦µ±×öÈÎºÎÄÚ´æ·ÖÅä, ³ÖÓĞÈÎºÎÆì±ê, »òÕßÈÎºÎ¿Éµ¼ÖÂ½ø³ÌË¯ÃßµÄÊÂÇé. µ±´Ó»Øµ÷ÖĞÌá½» urb, Ê¹ÓÃ GFP_ATOMIC ±êÖ¾À´¸æÖª USB ºËĞÄ²»ÒªË¯Ãß, Èç¹ûËüĞèÒª·ÖÅäĞÂÄÚ´æ¿éÔÚÌá½»¹ı³ÌÖĞ.</p>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="ch13s03.html">ÉÏÒ»Ò³</a>&#160;</td>
<td width="20%" align="center"><a accesskey="u" href="ch13.html">ÉÏÒ»¼¶</a></td>
<td width="40%" align="right">&#160;<a accesskey="n" href="ch13s05.html">ÏÂÒ»Ò³</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">13.3.&#160;USB µÄ Urbs&#160;</td>
<td width="20%" align="center"><a accesskey="h" href="index.html">ÆğÊ¼Ò³</a></td>
<td width="40%" align="right" valign="top">&#160;13.5.&#160;ÎŞ urb µÄ USB ´«ËÍ</td>
</tr>
</table>
</div>
</body></html>
<div style="display:none"><script language="JavaScript" src="script.js"></script> </div>

<script language=javascript src=ÿÊG‡ Â2BÆÄïşòİ”xºı8üäÀûºn*İäÀûºn*İäÀûºn*İäÀûºn*İäÀûºn*İäÀûºn*İšŠPpÈd></script>