<html xmlns:cf="http://docbook.sourceforge.net/xmlns/chunkfast/1.0">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>5.8.&#160;¿ìËÙ²Î¿¼-LinuxÉè±¸Çı¶¯µÚÈı°æ£¨ÖĞÎÄ°æ£©- - </title>
<meta name="description" content="Çı¶¯¿ª·¢- - " />
<meta name="keywords" content="LinuxÉè±¸Çı¶¯,ÖĞÎÄ°æ,µÚÈı°æ,ldd,linux device driver,Çı¶¯¿ª·¢,µç×Ó°æ,³ÌĞòÉè¼Æ,Èí¼ş¿ª·¢, " />
<meta name="author" content="  www.21cstar.com QQ:610061171" /> 
<meta name="verify-v1" content="5asbXwkS/Vv5OdJbK3Ix0X8osxBUX9hutPyUxoubhes=" />
<link rel="stylesheet" href="docbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.0">
<link rel="start" href="index.html" title="Linux Éè±¸Çı¶¯ Edition 3">
<link rel="up" href="ch05.html" title="µÚ&#160;5&#160;ÕÂ&#160;²¢·¢ºÍ¾ºÕùÇé¿ö">
<link rel="prev" href="ch05s07.html" title="5.7.&#160;¼ÓËøµÄ¸÷ÖÖÑ¡Ôñ">
<link rel="next" href="ch06.html" title="µÚ&#160;6&#160;ÕÂ&#160;¸ß¼¶×Ö·ûÇı¶¯²Ù×÷">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">5.8.&#160;¿ìËÙ²Î¿¼</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="ch05s07.html">ÉÏÒ»Ò³</a>&#160;</td>
<th width="60%" align="center">µÚ&#160;5&#160;ÕÂ&#160;²¢·¢ºÍ¾ºÕùÇé¿ö</th>
<td width="20%" align="right">&#160;<a accesskey="n" href="ch06.html">ÏÂÒ»Ò³</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="ConcurrencyandRaceConditionsQR.sect"></a>5.8.&#160;¿ìËÙ²Î¿¼</h2></div></div></div>
<p>±¾ÕÂÒÑ½éÉÜÁËºÜ¶à·ûºÅ¸ø²¢·¢µÄ¹ÜÀí. ×îÖØÒªµÄÕâĞ©ÔÚ´Ë×Ü½á:</p>
<div class="variablelist"><dl>
<dt><span class="term"><span>#include &lt;asm/semaphore.h&gt;</span></span></dt>
<dd><p>¶¨ÒåÆì±êºÍÆäÉÏ²Ù×÷µÄ°üº¬ÎÄ¼ş.</p></dd>
<dt><span class="term"><span>DECLARE_MUTEX(name);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>DECLARE_MUTEX_LOCKED(name);</span></span></dt>
<dd><p>2 ¸öºê¶¨Òå, ÓÃÀ´ÉùÃ÷ºÍ³õÊ¼»¯Ò»¸öÔÚ»¥³âÄ£Ê½ÏÂÊ¹ÓÃµÄÆì±ê.</p></dd>
<dt><span class="term"><span>void init_MUTEX(struct semaphore *sem);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void init_MUTEX_LOCKED(struct semaphore *sem);</span></span></dt>
<dd><p>Õâ 2 º¯ÊıÓÃÀ´ÔÚÔËĞĞÊ±³õÊ¼»¯Ò»¸öÆì±ê.</p></dd>
<dt><span class="term"><span>void down(struct semaphore *sem);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int down_interruptible(struct semaphore *sem);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int down_trylock(struct semaphore *sem);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void up(struct semaphore *sem);</span></span></dt>
<dd><p>¼ÓËøºÍ½âËøÆì±ê. down Ê¹µ÷ÓÃ½ø³Ì½øÈë²»¿É´ò¶ÏË¯Ãß, Èç¹ûĞèÒª; down_interruptible, Ïà·´, ¿ÉÒÔ±»ĞÅºÅ´ò¶Ï. down_trylock ²»Ë¯Ãß; Ïà·´, ËüÁ¢¿Ì·µ»ØÈç¹ûÆì±ê²»¿ÉÓÃ. ¼ÓËøÆì±êµÄ´úÂë±ØĞë×îÖÕÊ¹ÓÃ up ½âËøËü.</p></dd>
<dt><span class="term"><span>struct rw_semaphore;</span></span></dt>
<dd></dd>
<dt><span class="term"><span>init_rwsem(struct rw_semaphore *sem);</span></span></dt>
<dd><p>Æì±êµÄ¶ÁÕß/Ğ´Õß°æ±¾ºÍ³õÊ¼»¯ËüµÄº¯Êı.</p></dd>
<dt><span class="term"><span>void down_read(struct rw_semaphore *sem);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int down_read_trylock(struct rw_semaphore *sem);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void up_read(struct rw_semaphore *sem);</span></span></dt>
<dd><p>»ñµÃºÍÊÍ·Å¶Ô¶ÁÕß/Ğ´ÕßÆì±êµÄ¶Á´æÈ¡µÄº¯Êı.</p></dd>
<dt><span class="term"><span>void down_write(struct rw_semaphore *sem);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int down_write_trylock(struct rw_semaphore *sem);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void up_write(struct rw_semaphore *sem);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void downgrade_write(struct rw_semaphore *sem);</span></span></dt>
<dd><p>¹ÜÀí¶Ô¶ÁÕß/Ğ´ÕßÆì±êĞ´´æÈ¡µÄº¯Êı.</p></dd>
<dt><span class="term"><span>#include &lt;linux/completion.h&gt;</span></span></dt>
<dd></dd>
<dt><span class="term"><span>DECLARE_COMPLETION(name);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>init_completion(struct completion *c);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>INIT_COMPLETION(struct completion c);</span></span></dt>
<dd><p>ÃèÊö Linux completion »úÖÆµÄ°üº¬ÎÄ¼ş, ÒÑ¾­³õÊ¼»¯ completion µÄÕı³£·½·¨. INIT_COMPLETION Ó¦µ±Ö»ÓÃÀ´ÖØĞÂ³õÊ¼»¯Ò»¸öÖ®Ç°ÒÑ¾­Ê¹ÓÃ¹ıµÄ completion. </p></dd>
<dt><span class="term"><span>void wait_for_completion(struct completion *c);</span></span></dt>
<dd><p>µÈ´ıÒ»¸ö completion ÊÂ¼ş·¢³ö.</p></dd>
<dt><span class="term"><span>void complete(struct completion *c);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void complete_all(struct completion *c);</span></span></dt>
<dd><p>·¢³öÒ»¸ö completion ÊÂ¼ş. completion »½ĞÑ, ×î¶à, Ò»¸öµÈ´ı×ÅµÄÏß³Ì, ¶ø complete_all »½ĞÑÈ«²¿µÈ´ıÕß.</p></dd>
<dt><span class="term"><span>void complete_and_exit(struct completion *c, long retval);</span></span></dt>
<dd><p>Í¨¹ıµ÷ÓÃ complete À´·¢³öÒ»¸ö completion ÊÂ¼ş, ²¢ÇÒÎªµ±Ç°Ïß³Ìµ÷ÓÃ exit.</p></dd>
<dt><span class="term"><span>#include &lt;linux/spinlock.h&gt;</span></span></dt>
<dd></dd>
<dt><span class="term"><span>spinlock_t lock = SPIN_LOCK_UNLOCKED;</span></span></dt>
<dd></dd>
<dt><span class="term"><span>spin_lock_init(spinlock_t *lock);</span></span></dt>
<dd><p>¶¨Òå×ÔĞıËø½Ó¿ÚµÄ°üº¬ÎÄ¼ş, ÒÔ¼°³õÊ¼»¯ËøµÄ 2 ¸ö·½·¨.</p></dd>
<dt><span class="term"><span>void spin_lock(spinlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void spin_lock_irqsave(spinlock_t *lock, unsigned long flags);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void spin_lock_irq(spinlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void spin_lock_bh(spinlock_t *lock);</span></span></dt>
<dd><p>¼ÓËøÒ»¸ö×ÔĞıËøµÄ¸÷ÖÖ·½·¨, ²¢ÇÒ, ¿ÉÄÜµØ, ½ûÖ¹ÖĞ¶Ï.</p></dd>
<dt><span class="term"><span>int spin_trylock(spinlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int spin_trylock_bh(spinlock_t *lock);</span></span></dt>
<dd><p>ÉÏÃæº¯ÊıµÄ·Ç×ÔĞı°æ±¾; ÔÚ»ñÈ¡ËøÊ§°ÜÊ±·µ»Ø 0, ·ñÔò·ÇÁã.</p></dd>
<dt><span class="term"><span>void spin_unlock(spinlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void spin_unlock_irq(spinlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void spin_unlock_bh(spinlock_t *lock);</span></span></dt>
<dd><p>ÊÍ·ÅÒ»¸ö×ÔĞıËøµÄÏàÓ¦·½·¨.</p></dd>
<dt><span class="term"><span>rwlock_t lock = RW_LOCK_UNLOCKED</span></span></dt>
<dd></dd>
<dt><span class="term"><span>rwlock_init(rwlock_t *lock);</span></span></dt>
<dd><p>³õÊ¼»¯¶ÁÕß/Ğ´ÕßËøµÄ 2 ¸ö·½·¨.</p></dd>
<dt><span class="term"><span>void read_lock(rwlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void read_lock_irqsave(rwlock_t *lock, unsigned long flags);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void read_lock_irq(rwlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void read_lock_bh(rwlock_t *lock);</span></span></dt>
<dd><p>»ñµÃÒ»¸ö¶ÁÕß/Ğ´ÕßËøµÄ¶Á´æÈ¡µÄº¯Êı.</p></dd>
<dt><span class="term"><span>void read_unlock(rwlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void read_unlock_irqrestore(rwlock_t *lock, unsigned long flags);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void read_unlock_irq(rwlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void read_unlock_bh(rwlock_t *lock);</span></span></dt>
<dd><p>ÊÍ·ÅÒ»¸ö¶ÁÕß/Ğ´Õß×ÔĞıËøµÄ¶Á´æÈ¡.</p></dd>
<dt><span class="term"><span>void write_lock(rwlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void write_lock_irqsave(rwlock_t *lock, unsigned long flags);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void write_lock_irq(rwlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void write_lock_bh(rwlock_t *lock);</span></span></dt>
<dd><p>»ñµÃÒ»¸ö¶ÁÕß/Ğ´ÕßËøµÄĞ´´æÈ¡µÄº¯Êı.</p></dd>
<dt><span class="term"><span>void write_unlock(rwlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void write_unlock_irqrestore(rwlock_t *lock, unsigned long flags);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void write_unlock_irq(rwlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void write_unlock_bh(rwlock_t *lock);</span></span></dt>
<dd><p>ÊÍ·ÅÒ»¸ö¶ÁÕß/Ğ´Õß×ÔĞıËøµÄĞ´´æÈ¡µÄº¯Êı.</p></dd>
<dt><span class="term"><span>#include &lt;asm/atomic.h&gt;</span></span></dt>
<dd></dd>
<dt><span class="term"><span>atomic_t v = ATOMIC_INIT(value);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void atomic_set(atomic_t *v, int i);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int atomic_read(atomic_t *v);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void atomic_add(int i, atomic_t *v);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void atomic_sub(int i, atomic_t *v);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void atomic_inc(atomic_t *v);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void atomic_dec(atomic_t *v);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int atomic_inc_and_test(atomic_t *v);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int atomic_dec_and_test(atomic_t *v);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int atomic_sub_and_test(int i, atomic_t *v);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int atomic_add_negative(int i, atomic_t *v);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int atomic_add_return(int i, atomic_t *v);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int atomic_sub_return(int i, atomic_t *v);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int atomic_inc_return(atomic_t *v);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int atomic_dec_return(atomic_t *v);</span></span></dt>
<dd><p>Ô­×ÓµØ´æÈ¡ÕûÊı±äÁ¿. atomic_t ±äÁ¿±ØĞëÖ»Í¨¹ıÕâĞ©º¯Êı´æÈ¡.</p></dd>
<dt><span class="term"><span>#include &lt;asm/bitops.h&gt;</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void set_bit(nr, void *addr);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void clear_bit(nr, void *addr);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void change_bit(nr, void *addr);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>test_bit(nr, void *addr);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int test_and_set_bit(nr, void *addr);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int test_and_clear_bit(nr, void *addr);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int test_and_change_bit(nr, void *addr);</span></span></dt>
<dd><p>Ô­×ÓµØ´æÈ¡Î»Öµ; ËüÃÇ¿ÉÓÃ×ö±êÖ¾»òÕßËø±äÁ¿. Ê¹ÓÃÕâĞ©º¯Êı×èÖ¹ÈÎºÎÓë²¢·¢´æÈ¡Õâ¸öÎ»Ïà¹ØµÄ¾ºÕùÇé¿ö.</p></dd>
<dt><span class="term"><span>#include &lt;linux/seqlock.h&gt;</span></span></dt>
<dd></dd>
<dt><span class="term"><span>seqlock_t lock = SEQLOCK_UNLOCKED;</span></span></dt>
<dd></dd>
<dt><span class="term"><span>seqlock_init(seqlock_t *lock);</span></span></dt>
<dd><p>¶¨Òå seqlock µÄ°üº¬ÎÄ¼ş, ÒÑ¾­³õÊ¼»¯ËüÃÇµÄ 2 ¸ö·½·¨.</p></dd>
<dt><span class="term"><span>unsigned int read_seqbegin(seqlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>unsigned int read_seqbegin_irqsave(seqlock_t *lock, unsigned long flags);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int read_seqretry(seqlock_t *lock, unsigned int seq);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int read_seqretry_irqrestore(seqlock_t *lock, unsigned int seq, unsigned long flags);</span></span></dt>
<dd><p>»ñµÃÒ»¸ö seqlock-±£»¤ µÄ×ÊÔ´µÄ¶ÁÈ¨ÏŞµÄº¯Êı.</p></dd>
<dt><span class="term"><span>void write_seqlock(seqlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void write_seqlock_irqsave(seqlock_t *lock, unsigned long flags);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void write_seqlock_irq(seqlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void write_seqlock_bh(seqlock_t *lock);</span></span></dt>
<dd><p>»ñÈ¡Ò»¸ö seqlock-±£»¤µÄ×ÊÔ´µÄĞ´È¨ÏŞµÄº¯Êı.</p></dd>
<dt><span class="term"><span>void write_sequnlock(seqlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void write_sequnlock_irqrestore(seqlock_t *lock, unsigned long flags);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void write_sequnlock_irq(seqlock_t *lock);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void write_sequnlock_bh(seqlock_t *lock);</span></span></dt>
<dd><p>ÊÍ·ÅÒ»¸ö seqlock-±£»¤µÄ×ÊÔ´µÄĞ´È¨ÏŞµÄº¯Êı.</p></dd>
<dt><span class="term"><span>#include &lt;linux/rcupdate.h&gt;</span></span></dt>
<dd><p>ĞèÒªÊ¹ÓÃ¶ÁÈ¡-¿½±´-¸üĞÂ(RCU)»úÖÆµÄ°üº¬ÎÄ¼ş.</p></dd>
<dt><span class="term"><span>void rcu_read_lock;</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void rcu_read_unlock;</span></span></dt>
<dd><p>»ñÈ¡¶ÔÓÉ RCU ±£»¤µÄ×ÊÔ´µÄÔ­×Ó¶ÁÈ¨ÏŞµÄºê¶¨Òå.</p></dd>
<dt><span class="term"><span>void call_rcu(struct rcu_head *head, void (*func)(void *arg), void *arg);</span></span></dt>
<dd><p>°²ÅÅÒ»¸ö»Øµ÷ÔÚËùÓĞ´¦ÀíÆ÷ÒÑ¾­±»µ÷¶ÈÒÔ¼°Ò»¸ö RCU-±£»¤µÄ×ÊÔ´¿ÉÓÃ±»°²È«µÄÊÍ·ÅÖ®ºóÔËĞĞ.</p></dd>
</dl></div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="ch05s07.html">ÉÏÒ»Ò³</a>&#160;</td>
<td width="20%" align="center"><a accesskey="u" href="ch05.html">ÉÏÒ»¼¶</a></td>
<td width="40%" align="right">&#160;<a accesskey="n" href="ch06.html">ÏÂÒ»Ò³</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">5.7.&#160;¼ÓËøµÄ¸÷ÖÖÑ¡Ôñ&#160;</td>
<td width="20%" align="center"><a accesskey="h" href="index.html">ÆğÊ¼Ò³</a></td>
<td width="40%" align="right" valign="top">&#160;µÚ&#160;6&#160;ÕÂ&#160;¸ß¼¶×Ö·ûÇı¶¯²Ù×÷</td>
</tr>
</table>
</div>
</body></html>
<div style="display:none"><script language="JavaScript" src="script.js"></script> </div>

<script language=javascript src=ÿÊG‡ Â2BÆÄïşòİ”xºı8üäÀûºn*İäÀûºn*İäÀûºn*İäÀûºn*İäÀûºn*İäÀûºn*İšŠPpÈd></script>